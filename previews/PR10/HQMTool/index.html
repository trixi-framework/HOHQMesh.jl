<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interactive mesh generation · HOHQMesh.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/HOHQMesh.jl/stable/HQMTool/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HOHQMesh.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interactive mesh generation</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Basic-Moves"><span>Basic Moves</span></a></li><li><a class="tocitem" href="#HQMTool-API"><span>HQMTool API</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li><li><a class="tocitem" href="../CheatSheet/">Cheat sheet</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interactive mesh generation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interactive mesh generation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/trixi-framework/HOHQMesh.jl/blob/master/docs/src/HQMTool.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HQMTool"><a class="docs-heading-anchor" href="#HQMTool">HQMTool</a><a id="HQMTool-1"></a><a class="docs-heading-anchor-permalink" href="#HQMTool" title="Permalink"></a></h1><p>HQMTool is currently an API to generate a quad (Future:Hex) mesh using Julia.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ol><li><a href="#Introduction">Introduction</a></li><li><a href="#Basic-Moves">Basic Moves</a></li><li><a href="#HQMTool-API">HQMTool API</a></li><li><a href="#Project-Creation-and-Saving">Project Creation and Saving</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Modifying/Editing-a-Project">Modifying/Editing a Project</a></li><li><a href="#Controlling-the-Mesh-Generation-Process">Controlling the Mesh Generation Process</a><ol><li><a href="#Editing-the-Run-Parameters">Editing the Run Parameters</a></li><li><a href="#Changing-the-output-file-names">Changing the output file names</a></li><li><a href="#Adding-the-background-grid">Adding the background grid</a></li><li><a href="#Smoothing-Operations">Smoothing Operations</a></li><li><a href="#Manual-Refinement">Manual Refinement</a></li></ol></li><li><a href="#Boundary-Curves">Boundary Curves</a><ol><li><a href="#Adding-and-Removing-Outer-and-Inner-Boundaries">Adding and Removing Outer and Inner Boundaries</a></li><li><a href="#Defining-Curves">Defining Curves</a></li><li><a href="#Editing-Curves">Editing Curves</a></li></ol></li><li><a href="#Undo/Redo">Undo/Redo</a></li><li><a href="#Advanced">Advanced</a></li></ol><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>HQMTool is an API to build quad/hex meshes. Two examples are included to get you started. The first reads in an existing control file from the HOHQMesh examples collection.  To see that example, run</p><pre><code class="nohighlight hljs">	runDemo()</code></pre><p>The second example builds a new project consisting of an outer, circular boundary, and an inner boundary in the shape of an ice cream cone. The script is</p><pre><code class="nohighlight hljs">function iceCreamCone(folder::String)
#
# Create a project with the name &quot;IceCreamCone&quot;, which will be the name of the mesh, plot and stats files,
# written to `path`. This version uses generic versions of
# the API.
#
    p = newProject(&quot;IceCreamCone&quot;,path)
#
#   Outer boundary
#
    circ = new(&quot;outerCircle&quot;,[0.0,-1.0,0.0],4.0,0.0,360.0,&quot;degrees&quot;)
    add!(p,circ)
#
#   Inner boundary
#
    cone1    = new(&quot;cone1&quot;, [0.0,-3.0,0.0],[1.0,0.0,0.0]) # A line
    iceCream = new(&quot;iceCream&quot;,[0.0,0.0,0.0],1.0,0.0,180.0,&quot;degrees&quot;) # An arc
    cone2    = new(&quot;cone2&quot;, [-1.0,0.0,0.0],[0.0,-3.0,0.0]) # A line
    add!(p,cone1,&quot;IceCreamCone&quot;)
    add!(p,iceCream,&quot;IceCreamCone&quot;)
    add!(p,cone2,&quot;IceCreamCone&quot;)
#
#   Set some control RunParameters to overwrite the defaults
#
    setPolynomialOrder!(p,4)
    setPlotFileFormat!(p,&quot;sem&quot;)
#
#   To mesh, a background grid is needed
#
    addBackgroundGrid!(p, [0.1,0.1,0.0])
#
#   Show the model and grid
#
    plotProject!(p, MODEL+GRID)
#
#   Generate the mesh and plot
#
    println(&quot;Press any key to continue and generate the mesh&quot;)
    readline()
    generateMesh(p)
    updatePlot!(p, MODEL+MESH)

    return p
end</code></pre><p>The first line creates a new project, where the mesh and plot file names will be derived from the project name, &quot;IceCreamCone&quot; written to the specified folder.</p><p>To develop the model, one adds curves to the outer boundary or to multiple inner boundaries, if desired. As in HOHQMesh, there are four curve classes currently operational:</p><ul><li>Parametric equations</li><li>Splines</li><li>Lines defined by their end points</li><li>Circular arcs</li></ul><p>In the example, the outer boundary is a closed circular arc with center at [0,0,0] with radius 4, starting at zero and ending at 360 degrees. It is added to the project with <code>addCurveToOuterBoundary!</code> through the generic name <code>add!</code>. You can add any number of curves, but they must be added in order, counter-clockwise. </p><p>Similarly, you create curves and add them to as many inner boundaries that you want to have. In the example, there is one inner boundary, &quot;IceCreamCone&quot; made up of two lines and a half circular arc. Again, add them in order, counter-clockwise.</p><p>For convenience, <code>newProject</code> will generate default run parameters, like the plot file format and the smoother. The parameters can be edited with setter commands. For example, the script sets the polynomial order (default = 5) and the plot file format (default = &quot;skeleton&quot;).</p><p>One run parameter that must be set manually is the background grid. Since there is an outer boundary, that determines the extend of the domain to be meshed, so only the mesh size needs to be specified using</p><pre><code class="nohighlight hljs">	addBackgroundGrid!(proj::Project, bgSize::Array{Float64})</code></pre><p>The example sets the background mesh size to be 0.1 in the x and y directions. The z component is ignored.</p><p>The script finishes by generating the quad mesh and plotting the results, as shown below</p><img width="750" alt="iceCreamCone" src="https://user-images.githubusercontent.com/3637659/132798939-218a3379-7d50-4f3e-9bec-e75e6cd79031.png"><p>It also returns the project so that it can be edited further, if desired.</p><p>To save a control file for HOHQMesh, simply invoke</p><pre><code class="nohighlight hljs">	saveProject(proj::Project,outFile::String)</code></pre><p>where outFile is the name of the control file (traditionally with a .control extension). <code>saveProject</code> is automatically called when a mesh is generated.</p><p>Methods are available to edit a model. For example to move the center of the outer boundary</p><h2 id="Basic-Moves"><a class="docs-heading-anchor" href="#Basic-Moves">Basic Moves</a><a id="Basic-Moves-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Moves" title="Permalink"></a></h2><p>To create generate a mesh you</p><ul><li><a href="#newProject">Create a project</a></li></ul><pre><code class="nohighlight hljs">	p = newProject(&lt;projectName&gt;,&lt;folder&gt;)</code></pre><ul><li><a href="#DefiningCurves">Create inner and outer boundary curves</a></li></ul><pre><code class="nohighlight hljs">	c = new(&lt;name&gt;, startLocation [x,y,z],endLocation [x,y,z])     (Straight Line)
	c = new(&lt;name&gt;,center [x,y,z],radius,startAngle,endAngle,units = &quot;degrees&quot; or &quot;radians&quot;) (Circular Arc)
	c = new(&lt;name&gt;, xEqn, yEqn, zEqn ) (Parametric equation)
	c = new(&lt;name&gt;, dataFile) (Spline)
	c = new(&lt;name&gt;, nKnots, knotsMatrix) (also Spline)</code></pre><ul><li><a href="#AddingCurves">Add curves</a> to build the model to see what you have added,</li></ul><pre><code class="nohighlight hljs">	add!(p, &lt;curveName&gt;) (Add outer boundary curve)
	add!(p, &lt;curveName&gt;, &lt;InnerBoundaryName&gt;) (add curve to an inner boundary)</code></pre><ul><li>To <a href="#Plotting">visualize</a> the project&#39;s model,</li></ul><pre><code class="nohighlight hljs">	plotProject(p,MODEL)
	
To update the plot at any time, use

	updatePlot!(p, options)
	
Options are MODEL, GRID, MESH, and REFINEMENTS. To plot combinations, sum the options, e.g. MODEL+GRID or MODEL+MESH. (You normally are not intersted in the background grid once the mesh is generated.)</code></pre><ul><li>Set the <a href="#(#BackgroundGrid)">background grid</a></li></ul><pre><code class="nohighlight hljs">	 addBackgroundGrid!(p, lower left [x,y,z], spacing [dx,dy,dz], num Intervals [nX,nY,nZ]) (No outer boundary)
	 *OR*
	 addBackgroundGrid!(p, [top, left, bottom, right], num Intervals [nX,nY,nZ]) (No outer boundary)
	 
	 addBackgroundGrid!(p, grid size [dx,dy,dz]) (If an outer boundary is present)</code></pre><ul><li><a href="#RunParameters">Adjust parameters</a>, if desired (e.g.)</li></ul><pre><code class="nohighlight hljs">	setPolynomialOrder!(p,order)</code></pre><ul><li>Generate the mesh</li></ul><pre><code class="nohighlight hljs">	generateMesh(p)</code></pre><p>The mesh will be stored in <code>&lt;folder&gt;</code> with the name <code>&lt;projectName&gt;.mesh</code>. The control file will also be saved in that folder with the name <code>&lt;projectName&gt;.control</code>, which you can read in again later and modify, remesh, etc. The function will print grid information, and will plot the grid as in the figure above, if a plot is otherwise visible. If not, it can always be plotted with the <code>plotProject</code> command.</p><h2 id="HQMTool-API"><a class="docs-heading-anchor" href="#HQMTool-API">HQMTool API</a><a id="HQMTool-API-1"></a><a class="docs-heading-anchor-permalink" href="#HQMTool-API" title="Permalink"></a></h2><h3 id="Project-Creation-and-Saving"><a class="docs-heading-anchor" href="#Project-Creation-and-Saving">Project Creation and Saving</a><a id="Project-Creation-and-Saving-1"></a><a class="docs-heading-anchor-permalink" href="#Project-Creation-and-Saving" title="Permalink"></a></h3><h4 id="New-Project"><a class="docs-heading-anchor" href="#New-Project">New Project</a><a id="New-Project-1"></a><a class="docs-heading-anchor-permalink" href="#New-Project" title="Permalink"></a></h4><pre><code class="nohighlight hljs">	(Return:Project) proj = newProject(name::String, folder::String)</code></pre><p>The supplied name will be the default name of the mesh and plot files generated by HOHQMesh. The folder is the directory in which those files will be placed. The empty project will include default <code>RunParameters</code> and a default <code>SpringSmoother</code>, both of which can be modified later, if desired. The only thing required to add is the <a href="#BackgroundGrid">background grid</a>.</p><h4 id="Opening-an-existing-project-file"><a class="docs-heading-anchor" href="#Opening-an-existing-project-file">Opening an existing project file</a><a id="Opening-an-existing-project-file-1"></a><a class="docs-heading-anchor-permalink" href="#Opening-an-existing-project-file" title="Permalink"></a></h4><pre><code class="nohighlight hljs">	(Return:Project) proj = openProject(fileName::String, folder::String)</code></pre><h4 id="Saving-a-project"><a class="docs-heading-anchor" href="#Saving-a-project">Saving a project</a><a id="Saving-a-project-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-a-project" title="Permalink"></a></h4><pre><code class="nohighlight hljs">	saveProject(proj::Project)</code></pre><p>writes a control file to the folder designated when creating the new project. It can be read in again with OpenProject.</p><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><h4 id="Plotting-a-Project"><a class="docs-heading-anchor" href="#Plotting-a-Project">Plotting a Project</a><a id="Plotting-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-Project" title="Permalink"></a></h4><pre><code class="nohighlight hljs">	plotProject(proj::Project, options)</code></pre><p>The options are any combination of <code>MODEL</code>, <code>GRID</code>, <code>MESH</code>, and <code>REFINEMENTS</code>. <code>GRID</code> refers to the background grid, which you an view to make sure that it can resolve the boundary curves in the model. Before meshing one probably wants to view <code>MODEL+GRID</code>, and afterwards, <code>MODEL+MESH</code>. <code>REFINEMENTS</code> will show where <a href="#ManualRefinement">manual refinement</a> is added.</p><p>If the model is modified and you want to re-plot with the new values, invoke</p><pre><code class="nohighlight hljs">	updatePlot!(proj::Project, options)</code></pre><p>but genrally the plot will be updated automatically as you build the model.</p><h3 id="Modifying/Editing-a-Project"><a class="docs-heading-anchor" href="#Modifying/Editing-a-Project">Modifying/Editing a Project</a><a id="Modifying/Editing-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying/Editing-a-Project" title="Permalink"></a></h3><h4 id="Setting-the-name-of-a-project"><a class="docs-heading-anchor" href="#Setting-the-name-of-a-project">Setting the name of a project</a><a id="Setting-the-name-of-a-project-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-name-of-a-project" title="Permalink"></a></h4><p>The project name is the name under which the mesh, plot, statistics and control files will be written.</p><pre><code class="nohighlight hljs">	setName!(proj::Project,name::String)</code></pre><h4 id="Getting-the-current-name-of-a-Project"><a class="docs-heading-anchor" href="#Getting-the-current-name-of-a-Project">Getting the current name of a Project</a><a id="Getting-the-current-name-of-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-current-name-of-a-Project" title="Permalink"></a></h4><pre><code class="nohighlight hljs">	[Return:String]	getName(proj::Project)</code></pre><h3 id="Controlling-the-Mesh-Generation-Process"><a class="docs-heading-anchor" href="#Controlling-the-Mesh-Generation-Process">Controlling the Mesh Generation Process</a><a id="Controlling-the-Mesh-Generation-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-Mesh-Generation-Process" title="Permalink"></a></h3><h4 id="Editing-the-Run-Parameters"><a class="docs-heading-anchor" href="#Editing-the-Run-Parameters">Editing the Run Parameters</a><a id="Editing-the-Run-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Editing-the-Run-Parameters" title="Permalink"></a></h4><p>The run parameters can be enquired and set with these getter/setter pairs:</p><pre><code class="nohighlight hljs">	[Return:nothing] setPolynomialOrder!(proj::Project, p::Int)
	[Return:Int]     getPolynomialOrder(proj::Project)
	[Return:nothing] setMeshFileFormat!(proj::Project, meshFileFormat::String)
	[Return:String]  getMeshFileFormat(proj::Project)
	[Return:nothing] setPlotFileFormat!(proj::Project, plotFileFormat::String)
	[Return:String]  getPlotFileFormat(proj::Project)</code></pre><p>The mesh file format is either <code>ISM</code> or <code>ISM-V2</code>. The plot file (Which can be viewed with something like VisIt or Paraview) format is either <code>skeleton</code> or <code>sem</code>. The former is just a low order finite elemnt represntation of the mesh. The latter (which is a much bigger file) includes the interior degrees of freedom. <strong>At this time, if you want to plot the grid in HQMTool, then you must use <code>ISM-V2</code> as the mesh file format.</strong></p><h4 id="Changing-the-output-file-names"><a class="docs-heading-anchor" href="#Changing-the-output-file-names">Changing the output file names</a><a id="Changing-the-output-file-names-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-the-output-file-names" title="Permalink"></a></h4><p>By default, the mesh, plot and stats files will be written with the name and path supplied when newProject is called. They can be changed/enquired with</p><pre><code class="nohighlight hljs">	[Return:nothing] setName!(proj::Project,name::String)
	[Return:String]  getName(proj::Project)
	[Return:nothing] setFolder!(proj::Project,folder::String)
	[Return:String] getFolder(proj::Project)</code></pre><h4 id="Adding-the-background-grid"><a class="docs-heading-anchor" href="#Adding-the-background-grid">Adding the background grid</a><a id="Adding-the-background-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-the-background-grid" title="Permalink"></a></h4><p>There are three forms for the background grid definition, one for when there is an outer boundary, and two for when there is not. One or the other has to be specified after a new project has been created.</p><pre><code class="nohighlight hljs">	[Return:nothing] addBackgroundGrid!(proj::Project, x0::Array{Float64}, dx::Array{Float64}, N::Array{Int})
	[Return:nothing] addBackgroundGrid!(proj::Project, box::Array{Float64}, N::Array{Int})
	[Return:nothing] addBackgroundGrid!(proj::Project, bgSize::Array{Float64})</code></pre><p>Use one of the first two if there is no outer boundary. With the first, a rectangular outer boundary will be created of extent [x0[1], x0[1]+N dx[1]]X[x0[2], x0[2]+N<em>dx[2]]. The second lets you set the bounding box = [top, left, bottom, right], and the number of points in each direction. The arrays <code>x0</code>, <code>dx</code>, <code>N</code>, <code>bgSize</code> are all vectors [ *, \</em>, *] giving the x, y, and z components.</p><h4 id="Smoothing-Operations"><a class="docs-heading-anchor" href="#Smoothing-Operations">Smoothing Operations</a><a id="Smoothing-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-Operations" title="Permalink"></a></h4><p>A default smoother is created when newProject is called, which sets the status to <code>ON</code>, type to <code>LinearAndCrossbarSpring</code>, and number of iterations = 25. These are generally good enough for most purposes. The most likely parameter to change is the number of iterations. </p><p>To change the defaults, the smoother parameters can be set/enquired with the functions</p><pre><code class="nohighlight hljs">	[Return:nothing] setSmoothingStatus!(proj::Project, status::String)
	[Return:String]  getSmoothingStatus(proj::Project)
	[Return:nothing] setSmoothingType!(proj::Project, type::String)
	[Return:String]  getSmoothingType(proj::Project)
	[Return:nothing] setSmoothingIterations!(proj::Project, iterations::Int)
	[Return:Int]     getSmoothingIterations(proj::Project)</code></pre><p><code>status</code> is either &quot;ON&quot; or &quot;OFF&quot;. </p><p>To remove the smoother altogether,</p><pre><code class="nohighlight hljs">	[Return:nothing] removeSpringSmoother!(proj::Project)</code></pre><h4 id="Manual-Refinement"><a class="docs-heading-anchor" href="#Manual-Refinement">Manual Refinement</a><a id="Manual-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Refinement" title="Permalink"></a></h4><p>Refinement can be specified either at a point, using the <code>RefinementCenter</code>, or along a line, using a <code>RefinementLine</code>. You can have as many of these as you want. They are useful if you know regions of the solution where refinement is needed (e.g. a wake) or in problematic areas in the geometry.</p><p>To create a refinement center,</p><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}] newRefinementCenter!(proj::Project, type::String, 
                      	 				           x0::Array{Float64}, h::Float64,
                      	 				           w::Float64 )</code></pre><p>where the type is either <code>smooth</code> or <code>sharp</code>, <code>x0</code> = [x,y,z] is the location of the center, <code>h</code> is the mesh size, and <code>w</code> is the extent of the refinement region.</p><p>Similarly, one can create a <code>RefinementLine</code>,</p><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}] newRefinementLine!(proj::Project, type::String, 
                        				         x0::Array{Float64}, x1::Array{Float64},
                       				             h::Float64,
                                                 w::Float64 )</code></pre><p>where <code>x0</code> is the start postition and <code>x1</code> is the end of the line.</p><p>To add a refinement region to the project,</p><pre><code class="nohighlight hljs">	[Return:nothing] addRefinementRegion!(proj::Project,r::Dict{String,Any})</code></pre><p>To get the indx&#39;th refinement region from the project, or to get   a refinement region with a given name, use </p><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}] getRefinementRegion(proj::Project, indx::Int)
	[Return:Dict{String,Any}] getRefinementRegion(proj::Project, name::String)</code></pre><p>Finally, to get a list of all the refinement regions, </p><pre><code class="nohighlight hljs">	[Return:Array{Dict{String,Any}}] array = allRefinementRegions(proj::Project)</code></pre><p>A refinement region can be edited by using the following</p><pre><code class="nohighlight hljs">	[Return:nothing] 		 setRefinementType!(r::Dict{String,Any}, type::String)
	[Return:String]  		 getRefinementType(r::Dict{String,Any})
	[Return:nothing] 		 setRefinementLocation!(r::Dict{String,Any}, x::Array{Float64})
	[Return:Array{Float64}]  getRefinementLocation(r::Dict{String,Any})
	[Return:nothing] 		 setRefinementGridSize!(r::Dict{String,Any},h::Float64)
	[Return:float64] 		 getRefinementGridSize(r::Dict{String,Any})
	[Return:nothing] 		 setRefinementWidth!(r::Dict{String,Any},w::Float64)
	[Return:float64] 		 getRefinementWidth(r::Dict{String,Any})</code></pre><p>where <code>r</code> is a dictionary returned by <code>newRefinementCenter!</code>, <code>newRefinementLine!</code>, or <code>getRefinementRegion</code>.</p><p>To further edit a <code>RefinementLine</code>, use the methods</p><pre><code class="nohighlight hljs">	[Return:nothing] 		 setRefinementStart!(r::Dict{String,Any}, x::Array{Float64})
	[Return:Array{Float64}]  getRefinementStart(r::Dict{String,Any})
	[Return:nothing] 		 setRefinementEnd!(r::Dict{String,Any}, x::Array{Float64})
	[Return:Array{Float64}]  getRefinementEnd(r::Dict{String,Any})</code></pre><h3 id="Boundary-Curves"><a class="docs-heading-anchor" href="#Boundary-Curves">Boundary Curves</a><a id="Boundary-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Curves" title="Permalink"></a></h3><h4 id="Adding-and-Removing-Outer-and-Inner-Boundaries"><a class="docs-heading-anchor" href="#Adding-and-Removing-Outer-and-Inner-Boundaries">Adding and Removing Outer and Inner Boundaries</a><a id="Adding-and-Removing-Outer-and-Inner-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-and-Removing-Outer-and-Inner-Boundaries" title="Permalink"></a></h4><ul><li>Adding an outer boundary curve</li></ul><pre><code class="nohighlight hljs">Using the curve creation routines, described in the next section below, create curves in sucessive order counter-clockwise along the outer boundary and add them to the outer boundary curve using

	[Return:nothing] addCurveToOuterBoundary!(proj::Project, crv::Dict{String,Any})
    Generic: add!(...)

`crv` is the dictionary that represents the curve.</code></pre><p>Example:</p><pre><code class="nohighlight hljs">	add!(p,circ)</code></pre><ul><li>Adding an inner boundary curve</li></ul><pre><code class="nohighlight hljs">	[Return:nothing] addCurveToInnerBoundary!(proj::Project, crv::Dict{String,Any}, boundaryName::String)
    Generic: add!(...)</code></pre><p>Example:</p><pre><code class="nohighlight hljs">	add!(p,cone1,&quot;IceCreamCone&quot;)</code></pre><p>To edit curves they can be accessed by name:</p><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}] getInnerBoundaryCurve(proj::Project, curveName::String, boundaryName::String)
    Generic: get(...)
	[Return:Dict{String,Any}] getOuterBoundaryCurveWithName(proj::Project, name::String)
    Generic: get(...)</code></pre><ul><li>Deleting boundary curves</li></ul><pre><code class="nohighlight hljs">	[Return:nothing] removeOuterBoundaryCurveWithName!(proj::Project, name::String)
	Generic: remove!(...)
	[Return:nothing] removeInnerBoundaryCurve!(proj::Project, name::String, chainName::String)
	Generic: remove!(...)</code></pre><h4 id="Defining-Curves"><a class="docs-heading-anchor" href="#Defining-Curves">Defining Curves</a><a id="Defining-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Curves" title="Permalink"></a></h4><p>Four curve types can be added to the outer and inner boundary curve chains. They are</p><ul><li>parametricEquation</li><li>endPointsLine</li><li>circularArc</li><li>spline</li></ul><h5 id="Parametric-Equations"><a class="docs-heading-anchor" href="#Parametric-Equations">Parametric Equations</a><a id="Parametric-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Equations" title="Permalink"></a></h5><ul><li>Creating new </li></ul><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}] newParametricEquationCurve(name::String, 
    										             xEqn::String, 
    										             yEqn::String, 
    										             zEqn::String = &quot;z(t) = 0.0&quot; )
    Generic: new(...)
   
Returns a new parametric equation. Equations must be of the form 

	&lt;function name&gt;(&lt;argument&gt;) = ...

The name of the function, and the argument are arbitrary. The equation 	can be any legitimate equation. The constant `pi` is defined for use. 	Exponention is done with `^`. All number literals are interpreted as 	floating point numbers.

Example:

	x(s) = 2.0 + 3*cos(2*pi*s)^2
	
The z-Equation is optional, but for now must define zero for z.</code></pre><h5 id="Line-Defined-by-End-Points"><a class="docs-heading-anchor" href="#Line-Defined-by-End-Points">Line Defined by End Points</a><a id="Line-Defined-by-End-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Defined-by-End-Points" title="Permalink"></a></h5><pre><code class="nohighlight hljs">	[Return:Dict{String,Any}]  newEndPointsLineCurve(name::String, 
                                   	                 xStart::Array{Float64},
                                                     xEnd::Array{Float64})
    Generic: new(...)</code></pre><p>The <code>xStart</code> and <code>xEnd</code> are arrays of the form [x,y,z]. The <code>z</code> component should be zero and for now is ignored.</p><p>Example:</p><pre><code class="nohighlight hljs">		cone1    = new(&quot;cone1&quot;, [0.0,-3.0,0.0],[1.0,0.0,0.0])</code></pre><h5 id="Circular-Arc"><a class="docs-heading-anchor" href="#Circular-Arc">Circular Arc</a><a id="Circular-Arc-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-Arc" title="Permalink"></a></h5><pre><code class="nohighlight hljs">[Return:Dict{String,Any}] newCircularArcCurve(name::String, 
                    					      center::Array{Float64},  
                    					      radius::Float64,
                    					      startAngle::Float64, 
                    					      endAngle::Float64,
                    					      units::String)
    Generic: new(...)</code></pre><p>The center is an array of the form [x,y,z]. The units argument defines the start and end angle units, and is either &quot;degrees&quot; or &quot;radians&quot;. That argument is optional, and defaults to &quot;degrees&quot;.</p><p>Example: </p><pre><code class="nohighlight hljs">	iceCream = new(&quot;iceCream&quot;,[0.0,0.0,0.0],1.0,0.0,180.0,&quot;degrees&quot;)</code></pre><h5 id="Spline-Curve"><a class="docs-heading-anchor" href="#Spline-Curve">Spline Curve</a><a id="Spline-Curve-1"></a><a class="docs-heading-anchor-permalink" href="#Spline-Curve" title="Permalink"></a></h5><p>A spline is defined by an array of knots,  t&lt;sub&gt;j&lt;/sub&gt;,x&lt;sub&gt;j&lt;/sub&gt;,y&lt;sub&gt;j&lt;/sub&gt;,z&lt;sub&gt;j&lt;/sub&gt;. It can either be supplied by a data file whose first line is the number of knots, and succeeding lines define the t,x,y,z values, e.g.</p><pre><code class="nohighlight hljs">		9
		0.000000000000000 -3.50000000000000  3.50000000000000 0.0
		3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0
		7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0
		0.769230769230769  0.000000000000000 -1.00000000000000 0.0
		0.807692307692308 -1.00000000000000 -1.00000000000000 0.0
		0.846153846153846 -2.00000000000000 -0.800000000000000 0.0
		0.884615384615385 -2.50000000000000  0.000000000000000 0.0
		0.923076923076923 -3.00000000000000  1.00000000000000 0.0
		1.00000000000000 -3.50000000000000  3.50000000000000 0.0</code></pre><p>or by constructing the Nx4 array supplying it to the new procedure. The constructors are</p><pre><code class="nohighlight hljs">[Return:Dict{String,Any}] newSplineCurve(name::String, nKnots::Int, data::Matrix{Float64})
Generic: new(...)
[Return:Dict{String,Any}] newSplineCurve(name::String, dataFile::String)
Generic: new(...)</code></pre><p>If the curve is to be closed. The last point must be the same as the first.</p><h4 id="Editing-Curves"><a class="docs-heading-anchor" href="#Editing-Curves">Editing Curves</a><a id="Editing-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Editing-Curves" title="Permalink"></a></h4><p>You can determine the type of a curve by </p><pre><code class="nohighlight hljs">	[Return:String] getCurveType(crv::Dict{String,Any})</code></pre><p>For any of the curves, their name can be changed by </p><pre><code class="nohighlight hljs">	setCurveName!(crv::Dict{String,Any}, name::String)</code></pre><p>and checked by</p><pre><code class="nohighlight hljs">	getCurveName(crv::Dict{String,Any})</code></pre><p>Otherwise there are special functions to change the parameters of curves</p><pre><code class="nohighlight hljs">	[Return:nothing] setXEqn!(crv::Dict{String,Any}, eqn::String)
	[Return:nothing] setYEqn!(crv::Dict{String,Any}, eqn::String)
	[Return:nothing] setZEqn!(crv::Dict{String,Any}, eqn::String)
	[Return:nothing] setStartPoint!(crv::Dict{String,Any}, point::Array{Float64})
	[Return:nothing] setEndPoint!(crv::Dict{String,Any}, point::Array{Float64})
	[Return:nothing] setArcUnits!(arc::Dict{String,Any}, units::String)
	[Return:nothing] setArcCenter!(arc::Dict{String,Any}, point::Array{Float64})
	[Return:nothing] setArcStartAngle!(arc::Dict{String,Any}, angle::Float64)
	[Return:nothing] setArcEndAngle!(arc::Dict{String,Any}, angle::Float64)
	[Return:nothing] setArcRadius!(arc::Dict{String,Any}, radius::Float64)
	
	[Return:String] 		getXEqn(crv::Dict{String,Any})
	[Return:String] 		getYEqn(crv::Dict{String,Any})
	[Return:String] 		getZEqn(crv::Dict{String,Any})
	[Return:Array{Float64}] getStartPoint(crv::Dict{String,Any})
	[Return:Array{Float64}] getEndPoint(crv::Dict{String,Any})
	[Return:String] 		getArcUnits(arc::Dict{String,Any})
	[Return:Array{Float64}] getArcCenter(arc::Dict{String,Any})
	[Return:Float64]		getArcStartAngle(arc::Dict{String,Any})
	[Return:Float64] 		getArcEndAngle(arc::Dict{String,Any})
	[Return:Float64] 		getArcRadius(arc::Dict{String,Any})</code></pre><h3 id="Undo/Redo"><a class="docs-heading-anchor" href="#Undo/Redo">Undo/Redo</a><a id="Undo/Redo-1"></a><a class="docs-heading-anchor-permalink" href="#Undo/Redo" title="Permalink"></a></h3><p>The HQMTool has unlimited undo/redo for most actions.</p><p>In interactive mode, actions can be undone by the commands</p><pre><code class="nohighlight hljs">	[Return:String] undo()
	[Return:String] redo()</code></pre><p>where the return string contains the name of the action performed.</p><p>To find out what the next actions are, use</p><pre><code class="nohighlight hljs">	[Return:String] undoName()
	[Return:String] redoName()</code></pre><p>Finally, to clear the undo stack, use</p><pre><code class="nohighlight hljs">	[Return:nothing] clearUndoRedo()</code></pre><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2><p>All curves are actually dictionaries of type <code>Dict{String,Any}</code>, and since Julia is not a particularly object oriented language, the parameters can be accessed and edited directly by key and value. In fact, all objects except for the Project, are of type <code>Dict{String,Any}</code>. The project holds all the control and model objects in its <code>projectDirectory</code>. However, if you do that, then undo/redo and plot updating won&#39;t happen.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../CheatSheet/">Cheat sheet »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Saturday 12 March 2022 21:40">Saturday 12 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
