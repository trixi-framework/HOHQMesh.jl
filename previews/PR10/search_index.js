var documenterSearchIndex = {"docs":
[{"location":"HQMTool/#HQMTool","page":"Interactive mesh generation","title":"HQMTool","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"HQMTool is currently an API to generate a quad (Future:Hex) mesh using Julia.","category":"page"},{"location":"HQMTool/#Contents","page":"Interactive mesh generation","title":"Contents","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Introduction\nBasic Moves\nHQMTool API\nProject Creation and Saving\nPlotting\nModifying/Editing a Project\nControlling the Mesh Generation Process\nEditing the Run Parameters\nChanging the output file names\nAdding the background grid\nSmoothing Operations\nManual Refinement\nBoundary Curves\nAdding and Removing Outer and Inner Boundaries\nDefining Curves\nEditing Curves\nUndo/Redo\nAdvanced","category":"page"},{"location":"HQMTool/#Introduction","page":"Interactive mesh generation","title":"Introduction","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"HQMTool is an API to build quad/hex meshes. Two examples are included to get you started. The first reads in an existing control file from the HOHQMesh examples collection.  To see that example, run","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\trunDemo()","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The second example builds a new project consisting of an outer, circular boundary, and an inner boundary in the shape of an ice cream cone. The script is","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"function iceCreamCone(folder::String)\n#\n# Create a project with the name \"IceCreamCone\", which will be the name of the mesh, plot and stats files,\n# written to `path`. This version uses generic versions of\n# the API.\n#\n    p = newProject(\"IceCreamCone\",path)\n#\n#   Outer boundary\n#\n    circ = new(\"outerCircle\",[0.0,-1.0,0.0],4.0,0.0,360.0,\"degrees\")\n    add!(p,circ)\n#\n#   Inner boundary\n#\n    cone1    = new(\"cone1\", [0.0,-3.0,0.0],[1.0,0.0,0.0]) # A line\n    iceCream = new(\"iceCream\",[0.0,0.0,0.0],1.0,0.0,180.0,\"degrees\") # An arc\n    cone2    = new(\"cone2\", [-1.0,0.0,0.0],[0.0,-3.0,0.0]) # A line\n    add!(p,cone1,\"IceCreamCone\")\n    add!(p,iceCream,\"IceCreamCone\")\n    add!(p,cone2,\"IceCreamCone\")\n#\n#   Set some control RunParameters to overwrite the defaults\n#\n    setPolynomialOrder!(p,4)\n    setPlotFileFormat!(p,\"sem\")\n#\n#   To mesh, a background grid is needed\n#\n    addBackgroundGrid!(p, [0.1,0.1,0.0])\n#\n#   Show the model and grid\n#\n    plotProject!(p, MODEL+GRID)\n#\n#   Generate the mesh and plot\n#\n    println(\"Press any key to continue and generate the mesh\")\n    readline()\n    generateMesh(p)\n    updatePlot!(p, MODEL+MESH)\n\n    return p\nend","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The first line creates a new project, where the mesh and plot file names will be derived from the project name, \"IceCreamCone\" written to the specified folder.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To develop the model, one adds curves to the outer boundary or to multiple inner boundaries, if desired. As in HOHQMesh, there are four curve classes currently operational:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Parametric equations\nSplines\nLines defined by their end points\nCircular arcs","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"In the example, the outer boundary is a closed circular arc with center at [0,0,0] with radius 4, starting at zero and ending at 360 degrees. It is added to the project with addCurveToOuterBoundary! through the generic name add!. You can add any number of curves, but they must be added in order, counter-clockwise. ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Similarly, you create curves and add them to as many inner boundaries that you want to have. In the example, there is one inner boundary, \"IceCreamCone\" made up of two lines and a half circular arc. Again, add them in order, counter-clockwise.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"For convenience, newProject will generate default run parameters, like the plot file format and the smoother. The parameters can be edited with setter commands. For example, the script sets the polynomial order (default = 5) and the plot file format (default = \"skeleton\").","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"One run parameter that must be set manually is the background grid. Since there is an outer boundary, that determines the extend of the domain to be meshed, so only the mesh size needs to be specified using","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\taddBackgroundGrid!(proj::Project, bgSize::Array{Float64})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The example sets the background mesh size to be 0.1 in the x and y directions. The z component is ignored.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The script finishes by generating the quad mesh and plotting the results, as shown below","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"<img width=\"750\" alt=\"iceCreamCone\" src=\"https://user-images.githubusercontent.com/3637659/132798939-218a3379-7d50-4f3e-9bec-e75e6cd79031.png\">","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"It also returns the project so that it can be edited further, if desired.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To save a control file for HOHQMesh, simply invoke","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tsaveProject(proj::Project,outFile::String)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"where outFile is the name of the control file (traditionally with a .control extension). saveProject is automatically called when a mesh is generated.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Methods are available to edit a model. For example to move the center of the outer boundary","category":"page"},{"location":"HQMTool/#Basic-Moves","page":"Interactive mesh generation","title":"Basic Moves","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To create generate a mesh you","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Create a project","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tp = newProject(<projectName>,<folder>)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Create inner and outer boundary curves","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tc = new(<name>, startLocation [x,y,z],endLocation [x,y,z])     (Straight Line)\n\tc = new(<name>,center [x,y,z],radius,startAngle,endAngle,units = \"degrees\" or \"radians\") (Circular Arc)\n\tc = new(<name>, xEqn, yEqn, zEqn ) (Parametric equation)\n\tc = new(<name>, dataFile) (Spline)\n\tc = new(<name>, nKnots, knotsMatrix) (also Spline)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Add curves to build the model to see what you have added,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tadd!(p, <curveName>) (Add outer boundary curve)\n\tadd!(p, <curveName>, <InnerBoundaryName>) (add curve to an inner boundary)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To visualize the project's model,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tplotProject(p,MODEL)\n\t\nTo update the plot at any time, use\n\n\tupdatePlot!(p, options)\n\t\nOptions are MODEL, GRID, MESH, and REFINEMENTS. To plot combinations, sum the options, e.g. MODEL+GRID or MODEL+MESH. (You normally are not intersted in the background grid once the mesh is generated.)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Set the background grid","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t addBackgroundGrid!(p, lower left [x,y,z], spacing [dx,dy,dz], num Intervals [nX,nY,nZ]) (No outer boundary)\n\t *OR*\n\t addBackgroundGrid!(p, [top, left, bottom, right], num Intervals [nX,nY,nZ]) (No outer boundary)\n\t \n\t addBackgroundGrid!(p, grid size [dx,dy,dz]) (If an outer boundary is present)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Adjust parameters, if desired (e.g.)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tsetPolynomialOrder!(p,order)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Generate the mesh","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tgenerateMesh(p)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The mesh will be stored in <folder> with the name <projectName>.mesh. The control file will also be saved in that folder with the name <projectName>.control, which you can read in again later and modify, remesh, etc. The function will print grid information, and will plot the grid as in the figure above, if a plot is otherwise visible. If not, it can always be plotted with the plotProject command.","category":"page"},{"location":"HQMTool/#HQMTool-API","page":"Interactive mesh generation","title":"HQMTool API","text":"","category":"section"},{"location":"HQMTool/#Project-Creation-and-Saving","page":"Interactive mesh generation","title":"Project Creation and Saving","text":"","category":"section"},{"location":"HQMTool/#New-Project","page":"Interactive mesh generation","title":"New Project","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t(Return:Project) proj = newProject(name::String, folder::String)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The supplied name will be the default name of the mesh and plot files generated by HOHQMesh. The folder is the directory in which those files will be placed. The empty project will include default RunParameters and a default SpringSmoother, both of which can be modified later, if desired. The only thing required to add is the background grid.","category":"page"},{"location":"HQMTool/#Opening-an-existing-project-file","page":"Interactive mesh generation","title":"Opening an existing project file","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t(Return:Project) proj = openProject(fileName::String, folder::String)","category":"page"},{"location":"HQMTool/#Saving-a-project","page":"Interactive mesh generation","title":"Saving a project","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tsaveProject(proj::Project)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"writes a control file to the folder designated when creating the new project. It can be read in again with OpenProject.","category":"page"},{"location":"HQMTool/#Plotting","page":"Interactive mesh generation","title":"Plotting","text":"","category":"section"},{"location":"HQMTool/#Plotting-a-Project","page":"Interactive mesh generation","title":"Plotting a Project","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tplotProject(proj::Project, options)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The options are any combination of MODEL, GRID, MESH, and REFINEMENTS. GRID refers to the background grid, which you an view to make sure that it can resolve the boundary curves in the model. Before meshing one probably wants to view MODEL+GRID, and afterwards, MODEL+MESH. REFINEMENTS will show where manual refinement is added.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"If the model is modified and you want to re-plot with the new values, invoke","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tupdatePlot!(proj::Project, options)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"but genrally the plot will be updated automatically as you build the model.","category":"page"},{"location":"HQMTool/#Modifying/Editing-a-Project","page":"Interactive mesh generation","title":"Modifying/Editing a Project","text":"","category":"section"},{"location":"HQMTool/#Setting-the-name-of-a-project","page":"Interactive mesh generation","title":"Setting the name of a project","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The project name is the name under which the mesh, plot, statistics and control files will be written.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tsetName!(proj::Project,name::String)","category":"page"},{"location":"HQMTool/#Getting-the-current-name-of-a-Project","page":"Interactive mesh generation","title":"Getting the current name of a Project","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:String]\tgetName(proj::Project)","category":"page"},{"location":"HQMTool/#Controlling-the-Mesh-Generation-Process","page":"Interactive mesh generation","title":"Controlling the Mesh Generation Process","text":"","category":"section"},{"location":"HQMTool/#Editing-the-Run-Parameters","page":"Interactive mesh generation","title":"Editing the Run Parameters","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The run parameters can be enquired and set with these getter/setter pairs:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] setPolynomialOrder!(proj::Project, p::Int)\n\t[Return:Int]     getPolynomialOrder(proj::Project)\n\t[Return:nothing] setMeshFileFormat!(proj::Project, meshFileFormat::String)\n\t[Return:String]  getMeshFileFormat(proj::Project)\n\t[Return:nothing] setPlotFileFormat!(proj::Project, plotFileFormat::String)\n\t[Return:String]  getPlotFileFormat(proj::Project)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The mesh file format is either ISM or ISM-V2. The plot file (Which can be viewed with something like VisIt or Paraview) format is either skeleton or sem. The former is just a low order finite elemnt represntation of the mesh. The latter (which is a much bigger file) includes the interior degrees of freedom. At this time, if you want to plot the grid in HQMTool, then you must use ISM-V2 as the mesh file format.","category":"page"},{"location":"HQMTool/#Changing-the-output-file-names","page":"Interactive mesh generation","title":"Changing the output file names","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"By default, the mesh, plot and stats files will be written with the name and path supplied when newProject is called. They can be changed/enquired with","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] setName!(proj::Project,name::String)\n\t[Return:String]  getName(proj::Project)\n\t[Return:nothing] setFolder!(proj::Project,folder::String)\n\t[Return:String] getFolder(proj::Project)","category":"page"},{"location":"HQMTool/#Adding-the-background-grid","page":"Interactive mesh generation","title":"Adding the background grid","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"There are three forms for the background grid definition, one for when there is an outer boundary, and two for when there is not. One or the other has to be specified after a new project has been created.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] addBackgroundGrid!(proj::Project, x0::Array{Float64}, dx::Array{Float64}, N::Array{Int})\n\t[Return:nothing] addBackgroundGrid!(proj::Project, box::Array{Float64}, N::Array{Int})\n\t[Return:nothing] addBackgroundGrid!(proj::Project, bgSize::Array{Float64})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Use one of the first two if there is no outer boundary. With the first, a rectangular outer boundary will be created of extent [x0[1], x0[1]+N dx[1]]X[x0[2], x0[2]+Ndx[2]]. The second lets you set the bounding box = [top, left, bottom, right], and the number of points in each direction. The arrays x0, dx, N, bgSize are all vectors [ *, \\, *] giving the x, y, and z components.","category":"page"},{"location":"HQMTool/#Smoothing-Operations","page":"Interactive mesh generation","title":"Smoothing Operations","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"A default smoother is created when newProject is called, which sets the status to ON, type to LinearAndCrossbarSpring, and number of iterations = 25. These are generally good enough for most purposes. The most likely parameter to change is the number of iterations. ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To change the defaults, the smoother parameters can be set/enquired with the functions","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] setSmoothingStatus!(proj::Project, status::String)\n\t[Return:String]  getSmoothingStatus(proj::Project)\n\t[Return:nothing] setSmoothingType!(proj::Project, type::String)\n\t[Return:String]  getSmoothingType(proj::Project)\n\t[Return:nothing] setSmoothingIterations!(proj::Project, iterations::Int)\n\t[Return:Int]     getSmoothingIterations(proj::Project)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"status is either \"ON\" or \"OFF\". ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To remove the smoother altogether,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] removeSpringSmoother!(proj::Project)","category":"page"},{"location":"HQMTool/#Manual-Refinement","page":"Interactive mesh generation","title":"Manual Refinement","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Refinement can be specified either at a point, using the RefinementCenter, or along a line, using a RefinementLine. You can have as many of these as you want. They are useful if you know regions of the solution where refinement is needed (e.g. a wake) or in problematic areas in the geometry.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To create a refinement center,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}] newRefinementCenter!(proj::Project, type::String, \n                      \t \t\t\t\t           x0::Array{Float64}, h::Float64,\n                      \t \t\t\t\t           w::Float64 )","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"where the type is either smooth or sharp, x0 = [x,y,z] is the location of the center, h is the mesh size, and w is the extent of the refinement region.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Similarly, one can create a RefinementLine,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}] newRefinementLine!(proj::Project, type::String, \n                        \t\t\t\t         x0::Array{Float64}, x1::Array{Float64},\n                       \t\t\t\t             h::Float64,\n                                                 w::Float64 )","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"where x0 is the start postition and x1 is the end of the line.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To add a refinement region to the project,","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] addRefinementRegion!(proj::Project,r::Dict{String,Any})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To get the indx'th refinement region from the project, or to get   a refinement region with a given name, use ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}] getRefinementRegion(proj::Project, indx::Int)\n\t[Return:Dict{String,Any}] getRefinementRegion(proj::Project, name::String)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Finally, to get a list of all the refinement regions, ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Array{Dict{String,Any}}] array = allRefinementRegions(proj::Project)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"A refinement region can be edited by using the following","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] \t\t setRefinementType!(r::Dict{String,Any}, type::String)\n\t[Return:String]  \t\t getRefinementType(r::Dict{String,Any})\n\t[Return:nothing] \t\t setRefinementLocation!(r::Dict{String,Any}, x::Array{Float64})\n\t[Return:Array{Float64}]  getRefinementLocation(r::Dict{String,Any})\n\t[Return:nothing] \t\t setRefinementGridSize!(r::Dict{String,Any},h::Float64)\n\t[Return:float64] \t\t getRefinementGridSize(r::Dict{String,Any})\n\t[Return:nothing] \t\t setRefinementWidth!(r::Dict{String,Any},w::Float64)\n\t[Return:float64] \t\t getRefinementWidth(r::Dict{String,Any})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"where r is a dictionary returned by newRefinementCenter!, newRefinementLine!, or getRefinementRegion.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To further edit a RefinementLine, use the methods","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] \t\t setRefinementStart!(r::Dict{String,Any}, x::Array{Float64})\n\t[Return:Array{Float64}]  getRefinementStart(r::Dict{String,Any})\n\t[Return:nothing] \t\t setRefinementEnd!(r::Dict{String,Any}, x::Array{Float64})\n\t[Return:Array{Float64}]  getRefinementEnd(r::Dict{String,Any})","category":"page"},{"location":"HQMTool/#Boundary-Curves","page":"Interactive mesh generation","title":"Boundary Curves","text":"","category":"section"},{"location":"HQMTool/#Adding-and-Removing-Outer-and-Inner-Boundaries","page":"Interactive mesh generation","title":"Adding and Removing Outer and Inner Boundaries","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Adding an outer boundary curve","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Using the curve creation routines, described in the next section below, create curves in sucessive order counter-clockwise along the outer boundary and add them to the outer boundary curve using\n\n\t[Return:nothing] addCurveToOuterBoundary!(proj::Project, crv::Dict{String,Any})\n    Generic: add!(...)\n\n`crv` is the dictionary that represents the curve.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Example:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tadd!(p,circ)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Adding an inner boundary curve","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] addCurveToInnerBoundary!(proj::Project, crv::Dict{String,Any}, boundaryName::String)\n    Generic: add!(...)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Example:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tadd!(p,cone1,\"IceCreamCone\")","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To edit curves they can be accessed by name:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}] getInnerBoundaryCurve(proj::Project, curveName::String, boundaryName::String)\n    Generic: get(...)\n\t[Return:Dict{String,Any}] getOuterBoundaryCurveWithName(proj::Project, name::String)\n    Generic: get(...)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Deleting boundary curves","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] removeOuterBoundaryCurveWithName!(proj::Project, name::String)\n\tGeneric: remove!(...)\n\t[Return:nothing] removeInnerBoundaryCurve!(proj::Project, name::String, chainName::String)\n\tGeneric: remove!(...)","category":"page"},{"location":"HQMTool/#Defining-Curves","page":"Interactive mesh generation","title":"Defining Curves","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Four curve types can be added to the outer and inner boundary curve chains. They are","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"parametricEquation\nendPointsLine\ncircularArc\nspline","category":"page"},{"location":"HQMTool/#Parametric-Equations","page":"Interactive mesh generation","title":"Parametric Equations","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Creating new ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}] newParametricEquationCurve(name::String, \n    \t\t\t\t\t\t\t\t\t\t             xEqn::String, \n    \t\t\t\t\t\t\t\t\t\t             yEqn::String, \n    \t\t\t\t\t\t\t\t\t\t             zEqn::String = \"z(t) = 0.0\" )\n    Generic: new(...)\n   \nReturns a new parametric equation. Equations must be of the form \n\n\t<function name>(<argument>) = ...\n\nThe name of the function, and the argument are arbitrary. The equation \tcan be any legitimate equation. The constant `pi` is defined for use. \tExponention is done with `^`. All number literals are interpreted as \tfloating point numbers.\n\nExample:\n\n\tx(s) = 2.0 + 3*cos(2*pi*s)^2\n\t\nThe z-Equation is optional, but for now must define zero for z.","category":"page"},{"location":"HQMTool/#Line-Defined-by-End-Points","page":"Interactive mesh generation","title":"Line Defined by End Points","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:Dict{String,Any}]  newEndPointsLineCurve(name::String, \n                                   \t                 xStart::Array{Float64},\n                                                     xEnd::Array{Float64})\n    Generic: new(...)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The xStart and xEnd are arrays of the form [x,y,z]. The z component should be zero and for now is ignored.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Example:","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t\tcone1    = new(\"cone1\", [0.0,-3.0,0.0],[1.0,0.0,0.0])","category":"page"},{"location":"HQMTool/#Circular-Arc","page":"Interactive mesh generation","title":"Circular Arc","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"[Return:Dict{String,Any}] newCircularArcCurve(name::String, \n                    \t\t\t\t\t      center::Array{Float64},  \n                    \t\t\t\t\t      radius::Float64,\n                    \t\t\t\t\t      startAngle::Float64, \n                    \t\t\t\t\t      endAngle::Float64,\n                    \t\t\t\t\t      units::String)\n    Generic: new(...)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The center is an array of the form [x,y,z]. The units argument defines the start and end angle units, and is either \"degrees\" or \"radians\". That argument is optional, and defaults to \"degrees\".","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Example: ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\ticeCream = new(\"iceCream\",[0.0,0.0,0.0],1.0,0.0,180.0,\"degrees\")","category":"page"},{"location":"HQMTool/#Spline-Curve","page":"Interactive mesh generation","title":"Spline Curve","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"A spline is defined by an array of knots,  t<sub>j</sub>,x<sub>j</sub>,y<sub>j</sub>,z<sub>j</sub>. It can either be supplied by a data file whose first line is the number of knots, and succeeding lines define the t,x,y,z values, e.g.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t\t9\n\t\t0.000000000000000 -3.50000000000000  3.50000000000000 0.0\n\t\t3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0\n\t\t7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0\n\t\t0.769230769230769  0.000000000000000 -1.00000000000000 0.0\n\t\t0.807692307692308 -1.00000000000000 -1.00000000000000 0.0\n\t\t0.846153846153846 -2.00000000000000 -0.800000000000000 0.0\n\t\t0.884615384615385 -2.50000000000000  0.000000000000000 0.0\n\t\t0.923076923076923 -3.00000000000000  1.00000000000000 0.0\n\t\t1.00000000000000 -3.50000000000000  3.50000000000000 0.0","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"or by constructing the Nx4 array supplying it to the new procedure. The constructors are","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"[Return:Dict{String,Any}] newSplineCurve(name::String, nKnots::Int, data::Matrix{Float64})\nGeneric: new(...)\n[Return:Dict{String,Any}] newSplineCurve(name::String, dataFile::String)\nGeneric: new(...)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"If the curve is to be closed. The last point must be the same as the first.","category":"page"},{"location":"HQMTool/#Editing-Curves","page":"Interactive mesh generation","title":"Editing Curves","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"You can determine the type of a curve by ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:String] getCurveType(crv::Dict{String,Any})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"For any of the curves, their name can be changed by ","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tsetCurveName!(crv::Dict{String,Any}, name::String)","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"and checked by","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\tgetCurveName(crv::Dict{String,Any})","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Otherwise there are special functions to change the parameters of curves","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] setXEqn!(crv::Dict{String,Any}, eqn::String)\n\t[Return:nothing] setYEqn!(crv::Dict{String,Any}, eqn::String)\n\t[Return:nothing] setZEqn!(crv::Dict{String,Any}, eqn::String)\n\t[Return:nothing] setStartPoint!(crv::Dict{String,Any}, point::Array{Float64})\n\t[Return:nothing] setEndPoint!(crv::Dict{String,Any}, point::Array{Float64})\n\t[Return:nothing] setArcUnits!(arc::Dict{String,Any}, units::String)\n\t[Return:nothing] setArcCenter!(arc::Dict{String,Any}, point::Array{Float64})\n\t[Return:nothing] setArcStartAngle!(arc::Dict{String,Any}, angle::Float64)\n\t[Return:nothing] setArcEndAngle!(arc::Dict{String,Any}, angle::Float64)\n\t[Return:nothing] setArcRadius!(arc::Dict{String,Any}, radius::Float64)\n\t\n\t[Return:String] \t\tgetXEqn(crv::Dict{String,Any})\n\t[Return:String] \t\tgetYEqn(crv::Dict{String,Any})\n\t[Return:String] \t\tgetZEqn(crv::Dict{String,Any})\n\t[Return:Array{Float64}] getStartPoint(crv::Dict{String,Any})\n\t[Return:Array{Float64}] getEndPoint(crv::Dict{String,Any})\n\t[Return:String] \t\tgetArcUnits(arc::Dict{String,Any})\n\t[Return:Array{Float64}] getArcCenter(arc::Dict{String,Any})\n\t[Return:Float64]\t\tgetArcStartAngle(arc::Dict{String,Any})\n\t[Return:Float64] \t\tgetArcEndAngle(arc::Dict{String,Any})\n\t[Return:Float64] \t\tgetArcRadius(arc::Dict{String,Any})","category":"page"},{"location":"HQMTool/#Undo/Redo","page":"Interactive mesh generation","title":"Undo/Redo","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"The HQMTool has unlimited undo/redo for most actions.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"In interactive mode, actions can be undone by the commands","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:String] undo()\n\t[Return:String] redo()","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"where the return string contains the name of the action performed.","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"To find out what the next actions are, use","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:String] undoName()\n\t[Return:String] redoName()","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"Finally, to clear the undo stack, use","category":"page"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"\t[Return:nothing] clearUndoRedo()","category":"page"},{"location":"HQMTool/#Advanced","page":"Interactive mesh generation","title":"Advanced","text":"","category":"section"},{"location":"HQMTool/","page":"Interactive mesh generation","title":"Interactive mesh generation","text":"All curves are actually dictionaries of type Dict{String,Any}, and since Julia is not a particularly object oriented language, the parameters can be accessed and edited directly by key and value. In fact, all objects except for the Project, are of type Dict{String,Any}. The project holds all the control and model objects in its projectDirectory. However, if you do that, then undo/redo and plot updating won't happen.","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2021-present Michael Schlottke-LakemperPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"CheatSheet/#HQMTool-CheatSheet","page":"Cheat sheet","title":"HQMTool CheatSheet","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"Workflow:","category":"page"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"Create a project\nAdd boundary curves\nAdd a background grid\nAdd manual refinement (if desired)\nGenerate mesh","category":"page"},{"location":"CheatSheet/#Project","page":"Cheat sheet","title":"Project","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tp = newProject(<projectName>,<folder>)","category":"page"},{"location":"CheatSheet/#cs-plotting","page":"Cheat sheet","title":"Plotting","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tplotProject!(p,options)\n\tupdatePlot!(p,options)","category":"page"},{"location":"CheatSheet/#Curves","page":"Cheat sheet","title":"Curves","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tc = new(name, startLocation [x,y,z],endLocation [x,y,z])  *Straight Line*\n\tc = new(name,center [x,y,z],radius, startAngle, endAngle) *Circular Arc*\n\tc = new(name, xEqn, yEqn, zEqn )                          *Parametric equation*\n\tc = new(name, dataFile) \t\t\t                      *Spline*\n\tc = new(name, nKnots, knotsMatrix)                        *also Spline*","category":"page"},{"location":"CheatSheet/#cs-manual-refinement","page":"Cheat sheet","title":"Manual Refinement","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tr = newRefinementCenter(name, center, gridSize, radius )\n\tr = newRefinementLine(name,type, startPoint, endPoint, gridSize, width )","category":"page"},{"location":"CheatSheet/#Adding-to-a-Project","page":"Cheat sheet","title":"Adding to a Project","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tadd!(p, c) \t\t\t\t\t\t  *Add outer boundary curve*\n\tadd!(p, c, <InnerBoundaryName>)   *add curve to an inner boundary*\n\tadd!(p, r) \t\t\t\t\t\t  *Add refinement region*\n\n\taddBackgroundGrid!(p, [top, left, bottom, right], [nX,nY,nZ]) *No outer boundary*\n\taddBackgroundGrid!(p, [dx,dy,dz])                             *If an outer boundary is present*","category":"page"},{"location":"CheatSheet/#Accessing-items","page":"Cheat sheet","title":"Accessing items","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tcrv         = get(p,curveName)\t             *Get a curve in the outer boundary*\n\tcrv         = get(p,curveName, boundaryName) *Get a curve in an inner boundary*\n\tindx, chain = getChain(p,boundaryName)       *Get a complete inner boundary curve*\n\tr           = getRefinementRegion(p, name)","category":"page"},{"location":"CheatSheet/#Removing-from-Project","page":"Cheat sheet","title":"Removing from Project","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tremoveOuterboundary!(p) \t\t\t       *Entire outer boundary curve*\n\tremoveInnerBoundary!(p, innerBoundaryName) *Entire inner boundary curve\n\tremove!(p, name) \t\t\t\t\t       *Curve in outer boundary*\n\tremove!(p, name, innerBoundaryName)        *Curve in inner boundary*\n\tremoveRefinementRegion!(p,  name)","category":"page"},{"location":"CheatSheet/#Editing-items","page":"Cheat sheet","title":"Editing items","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"All items have set/get methods to edit them. Most actions have undo() and redo(). To find out what the next undo/redo actions are, use undoActionName() and redoActionName() to print them out.","category":"page"},{"location":"CheatSheet/#Meshing","page":"Cheat sheet","title":"Meshing","text":"","category":"section"},{"location":"CheatSheet/","page":"Cheat sheet","title":"Cheat sheet","text":"\tgenerateMesh(p)\n\tremoveMesh!(p)","category":"page"},{"location":"reference/#HOHQMesh.jl-API","page":"Reference","title":"HOHQMesh.jl API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = HOHQMesh","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HOHQMesh]","category":"page"},{"location":"reference/#HOHQMesh.add!-Tuple{HOHQMesh.Project, Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.add!","text":"add!(proj::Project, crv::Dict{String,Any}, boundaryName::String)\n\nAdd a curve to the inner boundary named boundaryName.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.add!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.add!","text":"add!(proj::Project, obj::Dict{String,Any})\n\nAdd a curve to the outer boundary or a refinement reion to  the project\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addBackgroundGrid!-Tuple{HOHQMesh.Project, Array{Float64, N} where N, Array{Float64, N} where N, Array{Int64, N} where N}","page":"Reference","title":"HOHQMesh.addBackgroundGrid!","text":"addBackgroundGrid!(proj::Project, x0::Array{Float64}, dx::Array{Float64}, N::Array{Int})\n\nAdd the background grid block using the left corner, x0, the  grid size dx, and the number of intervals in each direction. Use this when there is no outer boundary defined in the model. This version mimics HOHQMesh's  backgroundGrid block, but the version\n\naddBackgroundGrid!(proj::Project, box::Array{Float64},  N::Array{Int} )\n\nis a lot easier to use.\n\nTODO: Change HOHQMesh and delete this way to specify the domain and use the bounding box one instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addBackgroundGrid!-Tuple{HOHQMesh.Project, Array{Float64, N} where N, Array{Int64, N} where N}","page":"Reference","title":"HOHQMesh.addBackgroundGrid!","text":"addBackgroundGrid!(proj::Project, box::Array{Float64},  N::Array{Int} )\n\nAdd the background grid block with bounding box = [TOP, LEFT, BOTTOM, RIGHT]  and the number of intervals in each diredction. Use this when there is no outer boundary defined in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addBackgroundGrid!-Tuple{HOHQMesh.Project, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.addBackgroundGrid!","text":"addBackgroundGrid(proj::Project, bgSize::Array{Float64})\n\nAdd the background grid block with the grid size to be a 3-vector. Use this when there is an outer boundary defined in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addBackgroundGrid!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.addBackgroundGrid!","text":"addBackgroundGrid!(proj::Project, dict::Dict{String,Any})\n\nUsed only for undo/redo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addCurveToInnerBoundary!-Tuple{HOHQMesh.Project, Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.addCurveToInnerBoundary!","text":"addCurveToInnerBoundary!(proj::Project, crv::Dict{String,Any}, boundaryName::String)\n\nAdd a curve to the inner boundary with name boundaryName. If an inner boundary of that name does not exist, one is created.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addCurveToOuterBoundary!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.addCurveToOuterBoundary!","text":"addCurveToOuterBoundary!(proj::Project, crv::Dict{String,Any})\n\nAdd a curve to the outer boundary. The curves must be added in order counter-clockwise\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addInnerBoundaryWithName!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.addInnerBoundaryWithName!","text":"addInnerBoundaryWithName!(proj::Project,name::String)\n\nCreate a new empty inner boundary with the given name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addObserver-Tuple{Any, String, Any}","page":"Reference","title":"HOHQMesh.addObserver","text":"addObserver(observer::Any, note::String, fnction::Any)\n\nfnction is the function to be executed (called) when a  notification of name note is given.\n\nThe function called upon notification must have the signature fnction(observer, sender, args...)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addOuterBoundary!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.addOuterBoundary!","text":"addOuterBoundary!(proj::Project)\n\nAdd an empty outer boundary to the project. There can be only one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addRefinementRegion!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.addRefinementRegion!","text":"addRefinementRegion!(proj::Project,r::Dict{String,Any})\n\nAdd the refinement region to the project\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addRefinementRegionPoints!-Tuple{HOHQMesh.Project, Dict{String, Any}}","page":"Reference","title":"HOHQMesh.addRefinementRegionPoints!","text":"addRefinementRegionPoints!(proj::Project, r::Dict{String,Any})\n\nCompute and add to the project the plotting points for the refinement region\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.addRunParameters!","page":"Reference","title":"HOHQMesh.addRunParameters!","text":"addRunParameters!(proj::Project, \n    plotFormat::String     = \"skeleton\", \n    meshFileFormat::String = \"ISM-V2\", \n    polynomialOrder::Int   = 5)\n\nAdd a RUN_PARAMETERS block and set all the parameters in one call.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.addSpringSmoother!","page":"Reference","title":"HOHQMesh.addSpringSmoother!","text":"addSpringSmoother!(status::String, type::String, nIterations::Int)\n\nstatus is either `ON` or `OFF`\ntype   is either `LinearSpring` or `LinearAndCrossbarSpring`\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.bboxUnion-Tuple{Array{Float64, N} where N, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.bboxUnion","text":"bboxUnion(box1::Array{Float64}, box2::Array{Float64})\n\nReturns the union of two bounding boxes\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.curveBounds-Tuple{Matrix{Float64}}","page":"Reference","title":"HOHQMesh.curveBounds","text":"curveBounds(crvPoints::Array{Float64,2})\n\nFind the bounds of a single curve, discretized as an array\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.duplicateCurve-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.duplicateCurve","text":"duplicateCurve(crv::Dict{String,Any}, newName::String)\n\nDuplicate the given curve giving it the new name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.emptyBounds-Tuple{}","page":"Reference","title":"HOHQMesh.emptyBounds","text":"Returns an array that will always be ignored when unioned with  another bounding box.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.examples_dir-Tuple{}","page":"Reference","title":"HOHQMesh.examples_dir","text":"examples_dir()\n\nReturn the path to the directory with some example mesh setups.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.extract_mesh_file_format-Tuple{Any}","page":"Reference","title":"HOHQMesh.extract_mesh_file_format","text":"extract_mesh_file_format(control_file)\n\nReturn a string with the desired output format of the HOHQMesh generated mesh file. This information is given within the RUN_PARAMETERS of the CONTROL_INPUT block of the control file. See the HOHQMesh documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.generate_mesh-Tuple{Any}","page":"Reference","title":"HOHQMesh.generate_mesh","text":"generate_mesh(control_file;\n              output_directory=\"out\",\n              mesh_filename=nothing, plot_filename=nothing, stats_filename=nothing,\n              verbose=false)\n\nGenerate a mesh based on the control_file with the HOHQMesh mesh generator and store resulting files in output_directory.\n\nYou can set the mesh filename, the plot filename, and the statistics filename using the keyword arguments mesh_filename, plot_filename, and stats_filename, respectively. If set to nothing, the filenames for the mesh file, plot file, and statistics file are generated automatically from the control file name. For example, path/to/ControlFile.control will result in output files ControlFile.mesh, ControlFile.tec, and ControlFile.txt.\n\nYou can activate verbose output from HOHQMesh that prints additional messages and debugging mesh information with the keyword argument verbose.\n\nThis function returns the output to stdout of the HOHQMesh binary when generating the mesh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.get-Tuple{HOHQMesh.Project, String, String}","page":"Reference","title":"HOHQMesh.get","text":"get(proj::Project, curveName::String, boundaryName::String)\n\nGet the curve named curveName from the inner boundary named boundaryName\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.get-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.get","text":"get(proj::Project, curveName::String)\n\nGet the curve with name curveName from the outer boundary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getAllRefinementRegions-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getAllRefinementRegions","text":"allRefinementRegions(proj::Project)\n\nGet the list of refinement regions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getArcCenter-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getArcCenter","text":"getArcCenter(crv::Dict{String,Any}, point::Array{Float64})\n\nGet the center of a circular arc as an array\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getArcEndAngle-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getArcEndAngle","text":"getArcEndAngle(arc::Dict{String,Any}, angle::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getArcRadius-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getArcRadius","text":"getArcRadius(arc::Dict{String,Any}, radius::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getArcStartAngle-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getArcStartAngle","text":"getArcStartAngle(arc::Dict{String,Any}, angle::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getArcUnits!-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getArcUnits!","text":"getArcUnits(crv::Dict{String,Any}, units::String)\n\nGet the units for the start and end angles of a circular arc curve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getBackgroundGridLowerLeft-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getBackgroundGridLowerLeft","text":"function getBackgroundGridLowerLeft(proj::Project)\n\nReturns the [x,y] of the lower left point of thebackground grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getBackgroundGridSize-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getBackgroundGridSize","text":"getBackgroundGridSize(proj::Project)\n\nReturns the background grid size array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getBackgroundGridSteps-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getBackgroundGridSteps","text":"function getBackgroundGridLowerLeft(proj::Project)\n\nReturns the [x,y,z] of the lower left point of thebackground grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getCurveName-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getCurveName","text":"getCurveName(crv::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getCurveType-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getCurveType","text":"getCurveType(crv::Dic{String,Any})\n\nGet the type of the curve, `END_POINTSLINE_CURVE`, `PARAMETRIC_EQUATION_CURVE`,\n`SPLINE_CURVE`, or `CIRCULAR_ARC` as a string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getEndPoint-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getEndPoint","text":"getEndPoint(crv::Dict{String,Any}, point::Array{Float64})\n\nGet the end point for a line curve as an array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getInnerBoundary-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.getInnerBoundary","text":"getInnerBoundary(proj::Project, name::String)\n\nGet the chain of curves from the inner boundary with name name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getInnerBoundaryChainWithName-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.getInnerBoundaryChainWithName","text":"getInnerBoundaryWithName(proj::Project, name::String)\n\nGet the inner boundary CHAIN with the given name. If one does not exist, it is created.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getInnerBoundaryCurve-Tuple{HOHQMesh.Project, String, String}","page":"Reference","title":"HOHQMesh.getInnerBoundaryCurve","text":"\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getMeshFileFormat-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getMeshFileFormat","text":"getMeshFileFormat(proj::Project)\n\nReturns the format in which the mesh will be written.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getName-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getName","text":"getName(proj::Project)\n\nReturns the filename to be used by the mesh, plot, control, and  stats files.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getOuterBoundaryChainList-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getOuterBoundaryChainList","text":"getOuterBoundary(proj::Project)\n\nGet the array of outer boundary curves.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getOuterBoundaryCurveWithName-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.getOuterBoundaryCurveWithName","text":"getOuterBoundaryCurveWithName(proj::Project, name::String)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getPlotFileFormat-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getPlotFileFormat","text":"getPlotFileFormat(proj::Project)\n\nReturns the plot file format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getPolynomialOrder-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getPolynomialOrder","text":"getPolynomialOrder(proj::Project)\n\nReturns the polynomial order for boundary curves in the mesh file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementEnd-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementEnd","text":"getRefinementEnd(r::Dict{String,Any})\n\nReturn Array{Float64} of the end location of the refinement line\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementGridSize-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementGridSize","text":"getRefinementGridSize(r::Dict{String,Any})\n\nReturns the grid size,h, as Float64. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementLocation-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementLocation","text":"getRefinementLocation(r::Dict{String,Any})\n\nReturn Array{Float64} of the location of the refinement center.r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementName-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementName","text":"getRefinementName(r::Dict{String,Any})\n\nReturn name of the refinement. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementRegion-Tuple{HOHQMesh.Project, Int64}","page":"Reference","title":"HOHQMesh.getRefinementRegion","text":"getRefinementRegion(proj::Project, indx)\n\nGet the refinement region with index, indx from the project. Returns nothing if there is none. The return value is a dictionary that represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementRegion-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.getRefinementRegion","text":"(i,r) = getRefinementRegion(project, name)\n\nGet the refinement region with the given name and its location in the list of refinement regions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementStart-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementStart","text":"getRefinementStart  (r::Dict{String,Any})\n\nReturn Array{Float64} of the start location of the refinement line. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementType-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementType","text":"getRefinementType(r::Dict{String,Any})\n\nReturn the type of refinement, either \"smooth\" or \"sharp\". r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getRefinementWidth-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getRefinementWidth","text":"getRefinementWidth(r::Dict{String,Any})\n\nReturns the region width,w, as Float64. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getSmoothingIterations-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getSmoothingIterations","text":"\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getSmoothingStatus-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getSmoothingStatus","text":"smoothingStatus(proj::Project)\n\nReturns whether the smoother will be \"ON\" or \"OFF\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getSmoothingType-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getSmoothingType","text":"smoothingType(proj::Project)\n\nReturns either \"LinearSpring\" or \"LinearAndCrossbarSpring\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getSplineNKnots-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getSplineNKnots","text":"getSplineNKnots(spline::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getSplinePoints-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getSplinePoints","text":"getSplinePoints(spline::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getStartPoint-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getStartPoint","text":"getStartPoint(crv::Dict{String,Any}, point::Array{Float64})\n\nGet the start point for a line curve as an array\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getXEqn-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getXEqn","text":"getXEqn(crv::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getYEqn-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getYEqn","text":"getYEqn(crv::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getZEqn-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.getZEqn","text":"getZEqn(crv::Dict{String,Any})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.getfolder-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.getfolder","text":"path(proj::Project)\n\nReturns the directory where the project files will be written\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.hasBackgroundGrid-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.hasBackgroundGrid","text":"hasBackgroundGrid(proj::Project)\n\nTests to see if the project has a backgroundGrid dictionary defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.innerBoundaryIndices-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.innerBoundaryIndices","text":"innerBoundaryIndices(proj::Project, curveName::String)\n\nReturns (curveIndex,chainIndex) for the location of the curve named curveName in it's inner boundary chain.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.insertOuterBoundaryCurveAtIndex!-Tuple{HOHQMesh.Project, Dict{String, Any}, Int64}","page":"Reference","title":"HOHQMesh.insertOuterBoundaryCurveAtIndex!","text":"insertOuterBoundaryCurveAtIndex(proj::Project, crv::Dict{String,Any}, indx::Int)\n\nInsert a curve at the specified index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.insertRefinementRegion!-Tuple{HOHQMesh.Project, Dict{String, Any}, Int64}","page":"Reference","title":"HOHQMesh.insertRefinementRegion!","text":"insertRefinementRegion!(proj::Project, r::Dict{String,Any}, indx::Int)\n\nUsed by undo()\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.new","page":"Reference","title":"HOHQMesh.new","text":"new(name::String, \n    center::Array{Float64},  \n    radius::Float64,\n    startAngle::Float64, \n    endAngle::Float64,\n    units::String)\n\nCreate a new circular arc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.new-2","page":"Reference","title":"HOHQMesh.new","text":"new(name::String, \n    xEqn::String, \n    yEqn::String, \n    zEqn::String = \"z(t) = 0.0\" )\n\nCreate a new parametric equation curve.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.new-Tuple{String, Array{Float64, N} where N, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.new","text":"new(name::String,\n         xStart::Array{Float64},\n         xEnd::Array{Float64})\n\nCreate a new line defined by its end points.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.new-Tuple{String, Int64, Matrix{Float64}}","page":"Reference","title":"HOHQMesh.new","text":"new(name::String, nKnots::Int, data::Matrix{Float64})\n\nCreate a spline curve from an array of knots\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.new-Tuple{String, String}","page":"Reference","title":"HOHQMesh.new","text":"new(name::String, dataFile::String)\n\nCreate a spline curve from the contents of a data file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newCircularArcCurve","page":"Reference","title":"HOHQMesh.newCircularArcCurve","text":"newCircularArcCurve(name::String, center::Array{Float64},  \n    startAngle::Float64, endAngle::Float64,\n    units::String)\n\nCreates and returns a new circular arc curve in the form of a Dictionary\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.newEndPointsLineCurve-Tuple{String, Array{Float64, N} where N, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.newEndPointsLineCurve","text":"newEndPointsLineCurve(name::String, xStart::Array{Float64},xEnd::Array[Float64])\n\nCreates and returns a new curve defined by its end points in the form of a Dictionary\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newParametricEquationCurve","page":"Reference","title":"HOHQMesh.newParametricEquationCurve","text":"newParametricEquationCurve(name::String, \n    xEqn::String, \n    yEqn::String, \n    zEqn::String = \"z(t) = 0.0\" )\n\nCreates and returns a new parametricEquationCurve in the form of a Dictionary\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.newProject-Tuple{String, String}","page":"Reference","title":"HOHQMesh.newProject","text":"newProject(name::String, folder::String)\n\nCreate a new project with the given name. That name will be used for the mesh and plot files in the specified folder.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newRefinementCenter-Tuple{String, String, Array{Float64, N} where N, Float64, Float64}","page":"Reference","title":"HOHQMesh.newRefinementCenter","text":"newRefinementCenter(type,                            center, meshSize,                           width )\n\nCreate refinement center of type \"smooth\" or \"sharp\" centered at center = [x,y,z]with a mesh sizemeshSizespread over a radiuswidth`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newRefinementLine-Tuple{String, String, Array{Float64, N} where N, Array{Float64, N} where N, Float64, Float64}","page":"Reference","title":"HOHQMesh.newRefinementLine","text":"newRefinementLine(type, \n                    start, end,\n                    meshSize,\n                    width )\n\nCreate refinement line of type \"smooth\" or \"sharp\" between start = [x,y,z] and end = [x,y,z] with a mesh size meshSize spread over a width width.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newSplineCurve-Tuple{String, Int64, Matrix{Float64}}","page":"Reference","title":"HOHQMesh.newSplineCurve","text":"newSplineCurve(name::String, nKnots::Int, data::Array{Float64,4})\n\nReturns a spline curve given the number of knots and the array of knots.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.newSplineCurve-Tuple{String, String}","page":"Reference","title":"HOHQMesh.newSplineCurve","text":"newSplineCurve(name::String, dataFile::String)\n\nReturns a spline curve given a data file that contains the number of knots on the first line, and the spline data following that.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.openProject-Tuple{String, String}","page":"Reference","title":"HOHQMesh.openProject","text":"openProject(fileName::String, folder::String)\n\nOpen existing project described in the control File.\n\nfolder   = folder the control file is in\nfileNmae = the name of the file\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.plotProject!","page":"Reference","title":"HOHQMesh.plotProject!","text":"plotProject!(proj::Project, plotOptions::Int = 0)\n\nPlot objects specified by the plotOptions. Construct the plotOptions by the sum of what is to be drawn from the choices MODEL, GRID, MESH, REFINEMENTS. \n\nExample: To plot the model and the grid, plotOptions = MODEL + GRID. To plot just the mesh, plotOptions = MESH. \n\nTo plot everything, plotOptions = MODEL + GRID + MESH + REFINEMENTS\n\nContents are overlayed in the order: GRID, MESH, MODEL, REFINEMENTS\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.postNotificationWithName-Tuple{Any, String, Tuple}","page":"Reference","title":"HOHQMesh.postNotificationWithName","text":"postNotificationWithName(sender::Any, name::String, userInfo::Tuple)\n\nExecutes the function associated with the observer for the notification note\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.refinementRegionCenter-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.refinementRegionCenter","text":"refinementRegionCenter(r::Dict{String,Any})\n\nGet, or compute, the center of the given refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.refinementRegionPoints-Tuple{Dict{String, Any}}","page":"Reference","title":"HOHQMesh.refinementRegionPoints","text":"refinementRegionPoints(r::Dict{String,Any})\n\nReturns Array{Float64,2} being the plotting points of a refinement region\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.remove!-Tuple{HOHQMesh.Project, String, String}","page":"Reference","title":"HOHQMesh.remove!","text":"remove!(proj::Project, curveName::String, innerBoundaryName::String)\n\nDelete the curve named curveName from the inner boundary named innerBoundaryName\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.remove!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.remove!","text":"remove!(proj::Project, curveName::String)\n\nDelete the curve named curveName from the outer boundary\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeBackgroundGrid!-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.removeBackgroundGrid!","text":"removeBackgroundGrid!(proj::Project)\n\nRemove the background grid block from the project.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeInnerBoundary!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.removeInnerBoundary!","text":"removeInnerBoundary!(proj::Project, chainName::String)\n\nRemove an entire inner boundary\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeInnerBoundaryCurve!-Tuple{HOHQMesh.Project, String, String}","page":"Reference","title":"HOHQMesh.removeInnerBoundaryCurve!","text":"removeInnerBoundaryCurve!(proj::Project, name::String)\n\nRemove the named curve in the outer boundary\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeOuterBoundaryCurveWithName!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.removeOuterBoundaryCurveWithName!","text":"removeOuterBoundaryCurveWithName!(proj::Project, name::String)\n\nRemove the named curve in the outer boundary\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeOuterboundary!-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.removeOuterboundary!","text":"removeOuterboundary!(proj::Project)\n\nRemove the outer boundary curve if it exists.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeRefinementRegion!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.removeRefinementRegion!","text":"removeRefinementRegion!(proj::Project, name::String)\n\nDelete the named refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeRunParameters!-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.removeRunParameters!","text":"removeRunParameters!(proj::Project)\n\nRemove the run parameters block from the project.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.removeSpringSmoother!-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.removeSpringSmoother!","text":"removeSpringSmoother!(proj::Project)\n\nRemove the background grid block from the project.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.saveProject-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.saveProject","text":"saveProject(proj::Project)\n\nproj     = Project to be saved\n\nSave a project dictionary to the file path specified when the project was created.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setArcCenter!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setArcCenter!","text":"setArcCenter!(crv::Dict{String,Any}, point::Array{Float64})\n\nSet the center of a circular arc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setArcEndAngle!-Tuple{Dict{String, Any}, Float64}","page":"Reference","title":"HOHQMesh.setArcEndAngle!","text":"setArcEndAngle!(arc::Dict{String,Any}, angle::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setArcRadius!-Tuple{Dict{String, Any}, Float64}","page":"Reference","title":"HOHQMesh.setArcRadius!","text":"setArcRadius!(arc::Dict{String,Any}, radius::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setArcStartAngle!-Tuple{Dict{String, Any}, Float64}","page":"Reference","title":"HOHQMesh.setArcStartAngle!","text":"setArcStartAngle!(arc::Dict{String,Any}, angle::Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setArcUnits!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setArcUnits!","text":"setArcUnits(crv::Dict{String,Any}, units::String)\n\nSet the units for the start and end angles of a circular arc curve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setBackgroundGridLowerLeft!-Tuple{HOHQMesh.Project, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setBackgroundGridLowerLeft!","text":"setBackgroundGridLowerLeft!(proj::Project, x0::Array{Float64})\n\nSet the lower left location of the background grid for problems that have no outer boundary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setBackgroundGridSize!","page":"Reference","title":"HOHQMesh.setBackgroundGridSize!","text":"setBackgroundGridSpacing!(proj::Project, dx::Float64, dy::Float64, dz::Float64 = 0.0)\n\nUser facing function\n\n\n\n\n\n","category":"function"},{"location":"reference/#HOHQMesh.setBackgroundGridSize!-Tuple{HOHQMesh.Project, Array{Float64, N} where N, String}","page":"Reference","title":"HOHQMesh.setBackgroundGridSize!","text":"setBackgroundGridSize!(proj::Project, dx::Array{Float64},key::String)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setBackgroundGridSize!-Tuple{HOHQMesh.Project, Float64, Float64, String}","page":"Reference","title":"HOHQMesh.setBackgroundGridSize!","text":"setBackgroundGridSize!(proj::Project, dx::Float64, dy::Float64,key::String)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setBackgroundGridSteps!-Tuple{HOHQMesh.Project, Array{Int64, N} where N}","page":"Reference","title":"HOHQMesh.setBackgroundGridSteps!","text":"setBackgroundGridSteps!(proj::Project, N::Array{Int})\n\nSet how many steps of size setBackgroundGridSpacing in each direction the background grid extends from the lower left.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setCurveName!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setCurveName!","text":"setCurveName!(curveDict, name)\n\nSet the name of the curve represented by curveDict.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setEndPoint!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setEndPoint!","text":"setEndPoint!(crv::Dict{String,Any}, point::Array{Float64})\n\nSet the end point for a line curve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setFolder-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setFolder","text":"setFolder(proj::Project,folder::String)\n\nSet the path to the directory where the mesh, plot, control, and stats files will be written \n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setMeshFileFormat!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setMeshFileFormat!","text":"setMeshFileFormat(proj::Project, meshFileFormat::String)\n\nSet the file format for the mesh file. Acceptable choices are \"ISM\" and \"ISM-V2\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setName!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setName!","text":"setName(proj::Project,name::String)\n\nThe name of the project is the filename to be used by the mesh, plot, and  stats files. It is also the name of the control file the tool will produce.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setPlotFileFormat!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setPlotFileFormat!","text":"setPlotFileFormat(proj::Project, plotFileFormat::String)\n\nSet the file format for the plot file. Acceptable choices are \"sem\", which includes interior nodes and boundary nodes and \"skeleton\", which includes only the corner nodes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setPolynomialOrder!-Tuple{HOHQMesh.Project, Int64}","page":"Reference","title":"HOHQMesh.setPolynomialOrder!","text":"setPolynomialOrder(proj::Project, p::Int)\n\nSet the polynomial order for boundary curves in the mesh file to p.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementEnd!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setRefinementEnd!","text":"setRefinementEnd(refinementRegion, location)\n\nSet the end point location of a refinement line, location = [x, y, z].\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementGridSize!-Tuple{Dict{String, Any}, Float64}","page":"Reference","title":"HOHQMesh.setRefinementGridSize!","text":"setRefinementGridSize(r::Dict{String,Any}, h)\n\nSet the grid size, h for the refinement region. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementLocation!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setRefinementLocation!","text":"setRefinementLocation!(refinementCenter, location)\n\nSet the location of a refinement center to location = [x,y,z].\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementName!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setRefinementName!","text":"setRefinementName!(r::Dict{String,Any}, type)\n\nSet a name for the refinement region.r is the dictionary that      represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementStart!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setRefinementStart!","text":"setRefinementStart!(refinementRegion, location)\n\nSet the start point location of a refinement line, location = [x, y, z].\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementType!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setRefinementType!","text":"setRefinementType!(refinementRegion, type)\n\nSet the type, either \"smooth\" or \"sharp\" for the given refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setRefinementWidth!-Tuple{Dict{String, Any}, Float64}","page":"Reference","title":"HOHQMesh.setRefinementWidth!","text":"setRefinementWidth!(r::Dict{String,Any}, width)\n\nSet the width of the refinement region. r is the dictionary that  represents the refinement region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setSmoothingIterations!-Tuple{HOHQMesh.Project, Int64}","page":"Reference","title":"HOHQMesh.setSmoothingIterations!","text":"setSmoothingIterations!((proj::Project, iterations::Int)\n\nSet the number of iterations to smooth the mesh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setSmoothingStatus!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setSmoothingStatus!","text":"setSmoothingStatus(proj:Project, status::String)\n\nstatus is either \"ON\" or \"OFF\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setSmoothingType!-Tuple{HOHQMesh.Project, String}","page":"Reference","title":"HOHQMesh.setSmoothingType!","text":"setSmoothingType!(proj:Project, status::String)\n\ntype is either LinearSpring or LinearAndCrossbarSpring\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setSplineNKnots!-Tuple{Dict{String, Any}, Int64}","page":"Reference","title":"HOHQMesh.setSplineNKnots!","text":"setSplineNKnots!(spline::Dict{String,Any}, nKnots::Int)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setSplinePoints!-Tuple{Dict{String, Any}, Matrix{Float64}}","page":"Reference","title":"HOHQMesh.setSplinePoints!","text":"setSplinePoints!(spline::Dict{String,Any},points::Array{Float64,4})\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setStartPoint!-Tuple{Dict{String, Any}, Array{Float64, N} where N}","page":"Reference","title":"HOHQMesh.setStartPoint!","text":"setStartPoint!(crv::Dict{String,Any}, point::Array{Float64})\n\nSet the start point for a line curve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setXEqn!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setXEqn!","text":"setXEqn!(parametricEquationCurve, eqn)\n\nFor a parametric equation, set the x-equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setYEqn!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setYEqn!","text":"setYEqn!(parametricEquationCurve, eqn)\n\nFor a parametric equation, set the y-equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.setZEqn!-Tuple{Dict{String, Any}, String}","page":"Reference","title":"HOHQMesh.setZEqn!","text":"setZEqn!(parametricEquationCurve, eqn)\n\nFor a parametric equation, set the zEqn-equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.unRegisterForNotification-Tuple{Any, String}","page":"Reference","title":"HOHQMesh.unRegisterForNotification","text":"unRegisterForNotification(observer::Any, note::String)\n\nRemove the observer from being notified by the notification note\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.updatePlot!-Tuple{HOHQMesh.Project, Int64}","page":"Reference","title":"HOHQMesh.updatePlot!","text":"updatePlot!(proj::Project, plotOptions::Int)\n\nReplot with the new plotOptions = combinations (sums) of \n\nGRID, MESH, MODEL, REFINEMENTS\n\nExample: updatePlot(p, MESH + MODEL)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HOHQMesh.updatePlot!-Tuple{HOHQMesh.Project}","page":"Reference","title":"HOHQMesh.updatePlot!","text":"updatePlot!(proj::Project)\n\nThis version replots the figure with the current options. Legacy.\n\n\n\n\n\n","category":"method"},{"location":"#HOHQMesh.jl","page":"Home","title":"HOHQMesh.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a thin Julia wrapper around the High Order Hex-Quad Mesher (a.k.a. HOHQMesh) created and developed by David A. Kopriva. HOHQMesh.jl is available on Linux, MacOS, and Windows.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. HOHQMesh.jl works with Julia v1.6.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HOHQMesh.jl is a registered Julia package. Hence, you can install it by executing the following commands in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"HOHQMesh\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"HOHQMesh.jl depends on the binary distribution of the HOHQMesh mesh generator, which is available via the Julia package HOHQMesh_jll.jl and which is automatically installed as a dependency.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, you can load HOHQMesh with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using HOHQMesh","category":"page"},{"location":"","page":"Home","title":"Home","text":"and then happily generate away!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Two 2D examples GingerbreadMan and NACA0012 and a 3D example Snake (all from HOHQMesh itself) come delivered with this package. You can generate a mesh for them by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> control_file = joinpath(HOHQMesh.examples_dir(), \"GingerbreadMan.control\")\n\njulia> output = generate_mesh(control_file)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will then find the resulting output files (mesh, plot file, statistics) in the designated output directory, which defaults to out. The GingerbreadMan.control file will yield the following mesh,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: gingerbreadman_with_edges_400px)","category":"page"},{"location":"","page":"Home","title":"Home","text":"while the 3D file Snake.control produces this mesh:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: snake_400px)","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HOHQMesh.jl was initiated by Michael Schlottke-Lakemper (University of Cologne, Germany), who is also the principal developer of HOHQMesh.jl. The HOHQMesh mesh generator itself is developed by David A. Kopriva.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HOHQMesh.jl is licensed under the MIT license (see License). HOHQMesh itself is also available under the MIT license.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The authors would like to thank David A. Kopriva for making the sources of HOHQMesh available as open source, and for assisting with making it work with Julia.","category":"page"}]
}
