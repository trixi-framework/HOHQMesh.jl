<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · HOHQMesh.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/HOHQMesh.jl/stable/interactive-api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HOHQMesh.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Interactive mesh generation</span><ul><li><a class="tocitem" href="../interactive_overview/">Overview</a></li><li><a class="tocitem" href="../guided-tour/">Guided tour</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Project-creation-and-saving"><span>Project creation and saving</span></a></li><li><a class="tocitem" href="#Plotting-a-Project"><span>Plotting a <code>Project</code></span></a></li><li><a class="tocitem" href="#Modifying/editing-a-Project"><span>Modifying/editing a <code>Project</code></span></a></li><li><a class="tocitem" href="#Controlling-the-mesh-generation"><span>Controlling the mesh generation</span></a></li><li><a class="tocitem" href="#Boundary-curves"><span>Boundary curves</span></a></li><li><a class="tocitem" href="#Undo/redo"><span>Undo/redo</span></a></li></ul></li><li><a class="tocitem" href="../CheatSheet/">Commands Cheat Sheet</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/introduction/">Overview</a></li><li><a class="tocitem" href="../tutorials/straight_outer_boundary/">Straight-sided outer boundary</a></li><li><a class="tocitem" href="../tutorials/curved_outer_boundary/">Curved outer boundary</a></li><li><a class="tocitem" href="../tutorials/spline_curves/">Spline curves</a></li><li><a class="tocitem" href="../tutorials/create_edit_curves/">Creating and editing curves</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../testing/">Testing</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interactive mesh generation</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/trixi-framework/HOHQMesh.jl/blob/main/docs/src/interactive-api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Project-creation-and-saving"><a class="docs-heading-anchor" href="#Project-creation-and-saving">Project creation and saving</a><a id="Project-creation-and-saving-1"></a><a class="docs-heading-anchor-permalink" href="#Project-creation-and-saving" title="Permalink"></a></h2><h3 id="New-Project"><a class="docs-heading-anchor" href="#New-Project">New <code>Project</code></a><a id="New-Project-1"></a><a class="docs-heading-anchor-permalink" href="#New-Project" title="Permalink"></a></h3><pre><code class="nohighlight hljs">   [Return:Project] proj = newProject(name::String, folder::String)</code></pre><p>The supplied name will be the default name of the mesh and plot files generated by HOHQMesh. The folder is the directory in which those files will be placed. The empty project will include default <code>RunParameters</code> and a default <code>SpringSmoother</code>, both of which can be modified later, if desired. The only thing required to add is the background grid.</p><h3 id="Opening-an-existing-project-file"><a class="docs-heading-anchor" href="#Opening-an-existing-project-file">Opening an existing project file</a><a id="Opening-an-existing-project-file-1"></a><a class="docs-heading-anchor-permalink" href="#Opening-an-existing-project-file" title="Permalink"></a></h3><p>A project can be created from an existing HOHQMesh control file with</p><pre><code class="nohighlight hljs">   [Return:Project] proj = openProject(fileName::String, folder::String)</code></pre><p>The supplied <code>fileName</code> will be the name of the project and the generated mesh and plot files will be placed in the supplied <code>folder</code>.</p><h3 id="Saving-a-Project"><a class="docs-heading-anchor" href="#Saving-a-Project">Saving a <code>Project</code></a><a id="Saving-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-a-Project" title="Permalink"></a></h3><pre><code class="nohighlight hljs">   saveProject(proj::Project)</code></pre><p>writes a control file to the folder designated when creating the new project. It can be read in again with <code>openProject</code>.</p><h2 id="Plotting-a-Project"><a class="docs-heading-anchor" href="#Plotting-a-Project">Plotting a <code>Project</code></a><a id="Plotting-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-Project" title="Permalink"></a></h2><pre><code class="nohighlight hljs">   plotProject!(proj::Project, options)</code></pre><p>The plot options are any combination of <code>MODEL</code>, <code>GRID</code>, <code>REFINEMENTS</code>, and <code>MESH</code>. <code>MODEL</code> refers to any inner / outer boundary curves contained in the project. <code>GRID</code> refers to the background grid, which you an view to make sure that it can resolve the boundary curves in the model. <code>REFINEMENTS</code> will show the placement where user defined manual refinement regions are placed. <code>MESH</code> refers to the actual mesh of quadrilateral elements generated by HOHQMesh. Before meshing one probably wants to view <code>MODEL+GRID</code>, and afterwards, <code>MODEL+MESH</code>.</p><p>If the model is modified and you want to re-plot with the new values, invoke</p><pre><code class="nohighlight hljs">   updatePlot!(proj::Project, options)</code></pre><p>but generally the plot will be updated automatically as you build the model.</p><h2 id="Modifying/editing-a-Project"><a class="docs-heading-anchor" href="#Modifying/editing-a-Project">Modifying/editing a <code>Project</code></a><a id="Modifying/editing-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying/editing-a-Project" title="Permalink"></a></h2><h3 id="Setting-the-name-of-a-Project"><a class="docs-heading-anchor" href="#Setting-the-name-of-a-Project">Setting the name of a <code>Project</code></a><a id="Setting-the-name-of-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-name-of-a-Project" title="Permalink"></a></h3><p>The project name is the name under which the mesh, plot, statistics and control files will be written. It can be changed at any time with</p><pre><code class="nohighlight hljs">   setName!(proj::Project,name::String)</code></pre><h3 id="Getting-the-current-name-of-a-Project"><a class="docs-heading-anchor" href="#Getting-the-current-name-of-a-Project">Getting the current name of a <code>Project</code></a><a id="Getting-the-current-name-of-a-Project-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-current-name-of-a-Project" title="Permalink"></a></h3><p>The project name can be fetched and printed to the screen with</p><pre><code class="nohighlight hljs">   [Return:String] getName(proj::Project)</code></pre><h2 id="Controlling-the-mesh-generation"><a class="docs-heading-anchor" href="#Controlling-the-mesh-generation">Controlling the mesh generation</a><a id="Controlling-the-mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-mesh-generation" title="Permalink"></a></h2><h3 id="Editing-the-RunParameters"><a class="docs-heading-anchor" href="#Editing-the-RunParameters">Editing the <code>RunParameters</code></a><a id="Editing-the-RunParameters-1"></a><a class="docs-heading-anchor-permalink" href="#Editing-the-RunParameters" title="Permalink"></a></h3><p>The run parameters can be enquired and set with these getter/setter pairs:</p><pre><code class="nohighlight hljs">   [Return:nothing] setPolynomialOrder!(proj::Project, p::Int)
   [Return:Int]     getPolynomialOrder(proj::Project)
   [Return:nothing] setMeshFileFormat!(proj::Project, meshFileFormat::String)
   [Return:String]  getMeshFileFormat(proj::Project)
   [Return:nothing] setPlotFileFormat!(proj::Project, plotFileFormat::String)
   [Return:String]  getPlotFileFormat(proj::Project)</code></pre><p>HOHQMesh generates mesh files that contain high-order polynomial interpolations for any curved boundaries in the model. The degree of this polynomial representation is controlled by the above getter/setter pair. The default polynomial order is set to <code>5</code>.</p><p>The available mesh file formats are <code>&quot;ISM&quot;</code>, <code>&quot;ISM-V2&quot;</code>, or <code>&quot;ABAQUS&quot;</code>. See the HOHQMesh documentation, <a href="https://trixi-framework.github.io/HOHQMesh/appendix/#appendix-a-additions-for-ism-v2">Appendix A</a> or <a href="https://trixi-framework.github.io/HOHQMesh/appendix/#appendix-e-abaqus-mesh-file-format">Appendix E</a>, as well as the Trixi.jl documentation, <a href="https://trixi-framework.github.io/Trixi.jl/stable/meshes/unstructured_quad_mesh/">Unstructured quadrilateral mesh</a> or <a href="https://trixi-framework.github.io/Trixi.jl/stable/meshes/p4est_mesh/">P4est-based mesh</a>, for details and discussions on the latter two mesh file formats.</p><p>The plot file (which can be viewed with something like VisIt or ParaView) format is either <code>&quot;skeleton&quot;</code> or <code>&quot;sem&quot;</code>. The former is just a low order finite element representation of the mesh. The latter (which is a much bigger file) includes the interior degrees of freedom.</p><h3 id="Changing-the-output-file-names"><a class="docs-heading-anchor" href="#Changing-the-output-file-names">Changing the output file names</a><a id="Changing-the-output-file-names-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-the-output-file-names" title="Permalink"></a></h3><p>By default, the mesh, plot and stats files will be written with the name and path supplied when <code>newProject</code> is called. They can be changed/enquired with</p><pre><code class="nohighlight hljs">   [Return:nothing] setName!(proj::Project,name::String)
   [Return:String]  getName(proj::Project)
   [Return:nothing] setFolder!(proj::Project,folder::String)
   [Return:String]  getFolder(proj::Project)</code></pre><h3 id="Smoothing-operations"><a class="docs-heading-anchor" href="#Smoothing-operations">Smoothing operations</a><a id="Smoothing-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-operations" title="Permalink"></a></h3><p>A default smoother is created when <code>newProject</code> is called, which sets the status to <code>ON</code>, type to <code>LinearAndCrossbarSpring</code>, and number of iterations = 25. These are generally good enough for most purposes. The most likely parameter to change is the number of iterations. Further details on the smoothing strategy and how it works are available <a href="https://trixi-framework.github.io/HOHQMesh/the-control-input/#the-smoother">here</a>.</p><p>To change the defaults, the smoother parameters can be set/enquired with the functions</p><pre><code class="nohighlight hljs">   [Return:nothing] setSmoothingStatus!(proj::Project, status::String)
   [Return:String]  getSmoothingStatus(proj::Project)
   [Return:nothing] setSmoothingType!(proj::Project, type::String)
   [Return:String]  getSmoothingType(proj::Project)
   [Return:nothing] setSmoothingIterations!(proj::Project, iterations::Int)
   [Return:Int]     getSmoothingIterations(proj::Project)</code></pre><p>The smooth <code>status</code> is either &quot;ON&quot; or &quot;OFF&quot;.</p><p>To remove the smoother altogether, use</p><pre><code class="nohighlight hljs">   [Return:nothing] removeSpringSmoother!(proj::Project)</code></pre><h3 id="Adding-the-background-grid"><a class="docs-heading-anchor" href="#Adding-the-background-grid">Adding the background grid</a><a id="Adding-the-background-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-the-background-grid" title="Permalink"></a></h3><p>There are three forms for the background grid definition, one for when there is an outer boundary, and two for when there is not. One form of background grid <strong>must</strong> to be specified after a new project has been created.</p><pre><code class="nohighlight hljs">   [Return:nothing] addBackgroundGrid!(proj::Project,
                                       x0::Array{Float64},
                                       dx::Array{Float64},
                                       N::Array{Int})
   [Return:nothing] addBackgroundGrid!(proj::Project,
                                       box::Array{Float64},
                                       N::Array{Int})
   [Return:nothing] addBackgroundGrid!(proj::Project,
                                       bgSize::Array{Float64})</code></pre><p>Use one of the first two if there is no outer boundary present in the model. With the first, a rectangular outer boundary will be created of extent <code>[x0[1], x0[1] + N*dx[1]]</code> by <code>[x0[2], x0[2] + N*dx[2]]</code>. The second lets you set the bounding box = [top, left, bottom, right], and the number of points in each direction. The arrays <code>x0</code>, <code>dx</code>, and <code>N</code> are all vectors <code>[ *, *, * ]</code> giving the x, y, and z components. When an outer boundary is present use the third variant where one only need specify the desired background grid size with the vector <code>bgSize</code>.</p><h3 id="Changing-the-background-grid"><a class="docs-heading-anchor" href="#Changing-the-background-grid">Changing the background grid</a><a id="Changing-the-background-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-the-background-grid" title="Permalink"></a></h3><p>The size of an existing background grid in a <code>Project</code> can be adjusted with</p><pre><code class="nohighlight hljs">   [Return:nothing] setBackgroundGridSize!(proj::Project,
                                           dx::Float64,
                                           dy::Float64)</code></pre><p>If a plot is present it will be updated automatically.</p><h3 id="Manual-refinement-regions"><a class="docs-heading-anchor" href="#Manual-refinement-regions">Manual refinement regions</a><a id="Manual-refinement-regions-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-refinement-regions" title="Permalink"></a></h3><p>Refinement can be specified either at a point, using the <code>RefinementCenter</code>, or along a line, using a <code>RefinementLine</code>. You can have as many of these refinement regions as you want. They are useful if you know regions of the solution where refinement is needed (e.g. a wake) or in problematic areas of the geometry (e.g a sharp corner).</p><p>To create a <code>RefinementCenter</code>,</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newRefinementCenter(name::String,
                                                 type::String,
                                                 x0::Array{Float64},
                                                 h::Float64,
                                                 w::Float64)</code></pre><p>where <code>name</code> labels the refinement region, the <code>type</code> is either &quot;smooth&quot; or &quot;sharp&quot;, <code>x0</code> = [x, y, z] is the location of the center, <code>h</code> is the mesh size, and <code>w</code> is the extent of the refinement region. The z component must be zero.</p><p>Similarly, one can create a <code>RefinementLine</code>,</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newRefinementLine(name::String,
                                               type::String,
                                               x0::Array{Float64}, x1::Array{Float64},
                                               h::Float64,
                                               w::Float64)</code></pre><p>where <code>x0</code> is the start position and <code>x1</code> is the end of the line. The <code>name</code>, <code>type</code>, <code>h</code>, and <code>w</code> parameters are the same as for a <code>RefinementCenter</code>.</p><p>To add a refinement region to the project,</p><pre><code class="nohighlight hljs">   [Return:nothing] addRefinementRegion!(proj::Project, r::Dict{String,Any})</code></pre><p>To get a reference to a refinement region with a given name, use</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] getRefinementRegion(proj::Project, name::String)</code></pre><p>Finally, to get a list of all the refinement regions,</p><pre><code class="nohighlight hljs">    [Return:Array{Dict{String,Any}}] array = allRefinementRegions(proj::Project)</code></pre><p>A refinement region can be edited by using the following:</p><pre><code class="nohighlight hljs">   [Return:nothing]         setRefinementType!(r::Dict{String,Any}, type::String)
   [Return:String]          getRefinementType(r::Dict{String,Any})
   [Return:nothing]         setRefinementLocation!(r::Dict{String,Any}, x::Array{Float64})
   [Return:Array{Float64}]  getRefinementLocation(r::Dict{String,Any})
   [Return:nothing]         setRefinementGridSize!(r::Dict{String,Any}, h::Float64)
   [Return:Float64]         getRefinementGridSize(r::Dict{String,Any})
   [Return:nothing]         setRefinementWidth!(r::Dict{String,Any}, w::Float64)
   [Return:Float64]         getRefinementWidth(r::Dict{String,Any})</code></pre><p>where <code>r</code> is a dictionary returned by <code>newRefinementCenter!</code>, <code>newRefinementLine!</code>, or <code>getRefinementRegion</code>.</p><p>To further edit a <code>RefinementLine</code>, use the methods</p><pre><code class="nohighlight hljs">   [Return:nothing]         setRefinementStart!(r::Dict{String,Any}, x::Array{Float64})
   [Return:Array{Float64}]  getRefinementStart(r::Dict{String,Any})
   [Return:nothing]         setRefinementEnd!(r::Dict{String,Any}, x::Array{Float64})
   [Return:Array{Float64}]  getRefinementEnd(r::Dict{String,Any})</code></pre><h2 id="Boundary-curves"><a class="docs-heading-anchor" href="#Boundary-curves">Boundary curves</a><a id="Boundary-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-curves" title="Permalink"></a></h2><p>The <code>Project</code> contains a model that contains information about any inner and/or outer boundary curves that a user can add to define a domain to be meshed. Each curve is defined as a &quot;chain&quot; that can be built from multiple connected curves. More details on boundary curves and HOHQMesh can be found <a href="https://trixi-framework.github.io/HOHQMesh/the-model/">here</a>.</p><p>The domain can have a single outer boundary chain and an arbitrary number of inner boundary chains.</p><p>The orientation of any curve chains must be counter-clockwise. This orientation is automatically checked in <code>generate_mesh</code> and a warning is thrown if a user attempts to connect the curve chain in an invalid way.</p><p>See the tutorial <a href="../tutorials/create_edit_curves/#Creating-and-editing-curves">Creating and editing curves</a> for a demonstration of defining, constructing, and removing curves from a <code>Project</code>.</p><h3 id="Defining-curves"><a class="docs-heading-anchor" href="#Defining-curves">Defining curves</a><a id="Defining-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-curves" title="Permalink"></a></h3><p>Four curve types can be added to the outer and inner boundary curve chains. They are</p><ul><li>Parametric equations</li><li>Cubic Splines</li><li>Lines defined by their end points</li><li>Circular arcs</li></ul><h4 id="Parametric-equations"><a class="docs-heading-anchor" href="#Parametric-equations">Parametric equations</a><a id="Parametric-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-equations" title="Permalink"></a></h4><p>Creating a new curve equation</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newParametricEquationCurve(name::String,
                                                        xEqn::String,
                                                        yEqn::String,
                                                        zEqn::String = &quot;z(t) = 0.0&quot;)</code></pre><p>Returns a new set of parametric equation. Equations must be of the form</p><pre><code class="nohighlight hljs">   &lt;function name&gt;(&lt;argument&gt;) = ...</code></pre><p>The name of the function, and the argument are arbitrary. The equation can be any legitimate equation. The constant <code>pi</code> is defined for use. Exponentiation is done with <code>^</code>. All number literals are interpreted as floating point numbers.</p><p>Example:</p><pre><code class="language-julia hljs">   xEqn = &quot;x(t) = 4*cos(2*pi*t) - 0.6*cos(8*pi*t)^3&quot;
   yEqn = &quot;y(t) = 4*sin(2*pi*t) - 0.5*sin(11*pi*t)^2&quot;
   zEqn = &quot;z(t) = 0.0&quot;
   blob = newParametricEquationCurve(&quot;Blob&quot;, xEqn, yEqn, zEqn)</code></pre><p>The z-Equation is optional, but for now must define zero for z by default.</p><h4 id="Cubic-spline-curve"><a class="docs-heading-anchor" href="#Cubic-spline-curve">Cubic spline curve</a><a id="Cubic-spline-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-spline-curve" title="Permalink"></a></h4><p>A cubic spline is defined by an array of knots, <span>$t_j$</span>, <span>$x_j$</span>, <span>$y_j$</span>, <span>$z_j$</span>. It can either be supplied by a data file whose first line is the number of knots, and succeeding lines define the <span>$t$</span>, <span>$x$</span>, <span>$y$</span>, <span>$z$</span> values, e.g.</p><pre><code class="nohighlight hljs">   9
   0.000000000000000 -3.50000000000000  3.50000000000000 0.0
   3.846153846153846E-002 -3.20000000000000  5.00000000000 0.0
   7.692307692307693E-002 -2.00000000000000  6.00000000000 0.0
   0.769230769230769  0.000000000000000 -1.00000000000000 0.0
   0.807692307692308 -1.00000000000000 -1.00000000000000 0.0
   0.846153846153846 -2.00000000000000 -0.800000000000000 0.0
   0.884615384615385 -2.50000000000000  0.000000000000000 0.0
   0.923076923076923 -3.00000000000000  1.00000000000000 0.0
   1.00000000000000 -3.50000000000000  3.50000000000000 0.0</code></pre><p>or by constructing the required <code>nKnots</code> x <code>4</code> array and supplying it to the new procedure. The respective constructors for a spline curve are</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newSplineCurve(name::String,
                                            dataFile::String)
   [Return:Dict{String,Any}] newSplineCurve(name::String,
                                            nKnots::Int,
                                            data::Matrix{Float64})</code></pre><p>If the spline curve is to be closed. The last data point must be the same as the first.</p><p>Example:</p><pre><code class="language-julia hljs">   spline_data = [ [0.0  1.75 -1.0 0.0]
                   [0.25 2.1  -0.5 0.0]
                   [0.5  2.7  -1.0 0.0]
                   [0.75 0.6  -2.0 0.0]
                   [1.0  1.75 -1.0 0.0] ]
   ex_spline = newSplineCurve(&quot;small_spline&quot;, 5, spline_data)</code></pre><h4 id="Line-defined-by-end-points"><a class="docs-heading-anchor" href="#Line-defined-by-end-points">Line defined by end points</a><a id="Line-defined-by-end-points-1"></a><a class="docs-heading-anchor-permalink" href="#Line-defined-by-end-points" title="Permalink"></a></h4><p>A straight line is constructed with</p><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newEndPointsLineCurve(name::String,
                                                   xStart::Array{Float64},
                                                   xEnd::Array{Float64})</code></pre><p>The <code>xStart</code> and <code>xEnd</code> are arrays of the form [x, y, z]. The <code>z</code> component should be zero and for now is ignored.</p><p>Example:</p><pre><code class="language-julia hljs">   line1 = newEndPointsLineCurve(&quot;line_segment&quot;, [0.0, -3.0, 0.0], [1.0, 0.0, 0.0])</code></pre><h4 id="Circular-arc"><a class="docs-heading-anchor" href="#Circular-arc">Circular arc</a><a id="Circular-arc-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-arc" title="Permalink"></a></h4><pre><code class="nohighlight hljs">   [Return:Dict{String,Any}] newCircularArcCurve(name::String,
                                                 center::Array{Float64},
                                                 radius::Float64,
                                                 startAngle::Float64,
                                                 endAngle::Float64,
                                                 units::String)</code></pre><p>The center is an array of the form [x, y, z]. The units argument defines the start and end angle units. It is either &quot;degrees&quot; or &quot;radians&quot;. That argument is optional, and defaults to &quot;degrees&quot;.</p><p>Example:</p><pre><code class="language-julia hljs">   halfCircle = newCircularArcCurve(&quot;Dome&quot;, [0.0, 0.0, 0.0], 1.0, 0.0, 180.0, &quot;degrees&quot;)</code></pre><h3 id="Adding-and-removing-outer-and-inner-boundaries"><a class="docs-heading-anchor" href="#Adding-and-removing-outer-and-inner-boundaries">Adding and removing outer and inner boundaries</a><a id="Adding-and-removing-outer-and-inner-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-and-removing-outer-and-inner-boundaries" title="Permalink"></a></h3><ol><li><p>Adding an outer boundary curve</p><p>Using the curve creation routines described above, create curves counter-clockwise along the outer boundary and add them to the outer boundary curve using</p><pre><code class="nohighlight hljs">[Return:nothing] addCurveToOuterBoundary!(proj::Project,
                                          crv::Dict{String,Any})</code></pre><p><code>crv</code> is the dictionary that represents the curve.</p><p>Example:</p><pre><code class="language-julia hljs">circ = newCircularArcCurve(&quot;outerCircle&quot;, [0.0, -1.0, 0.0], 4.0, 0.0, 360.0, &quot;degrees&quot;)
addCurveToOuterBoundary!(p, circ)</code></pre></li><li><p>Adding an inner boundary curve</p><p>The syntax is analogous to the creation of an outer boundary curve. Once interior curves are defined they can be added to chain, again in counter-clockwise orientation. Note that the individual pieces of the curve are given a name. The entire chain is also given a name.</p><pre><code class="nohighlight hljs">[Return:nothing] addCurveToInnerBoundary!(proj::Project,
                                          crv::Dict{String,Any},
                                          chainName::String)</code></pre><p>Example:</p><pre><code class="language-julia hljs">line1 = newEndPointsLineCurve(&quot;line_segment&quot;, [0.0, -3.0, 0.0], [1.0, 0.0, 0.0])
addCurveToInnerBoundary!(p, line1, &quot;interior_curve&quot;)</code></pre><p>To edit curves they can be accessed by the name:</p><pre><code class="nohighlight hljs">[Return:Dict{String,Any}] getInnerBoundaryCurve(proj::Project,
                                                curveName::String,
                                                chainName::String)
[Return:Dict{String,Any}] getOuterBoundaryCurveWithName(proj::Project,
                                                        name::String)</code></pre></li><li><p>Deleting boundary curves</p><p>The entire outer boundary or an entire inner boundary can be removed from the project.</p><pre><code class="nohighlight hljs">[Return:nothing] removeOuterBoundary!(proj::Project)
[Return:nothing] removeInnerBoundary!(proj::Project, chainName::String)</code></pre><p>Alternatively, individual pieces of the boundary curve chains can be removed.</p><pre><code class="nohighlight hljs">[Return:nothing] removeOuterBoundaryCurveWithName!(proj::Project, name::String)
[Return:nothing] removeInnerBoundaryCurve!(proj::Project,
                                           name::String,
                                           chainName::String)</code></pre><p>As in HOHQMesh the project can have only one outer boundary chain, so the removal does not require a specific <code>chainName</code>.</p></li></ol><h3 id="Editing-curves"><a class="docs-heading-anchor" href="#Editing-curves">Editing curves</a><a id="Editing-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Editing-curves" title="Permalink"></a></h3><p>You can determine the type of a curve by</p><pre><code class="nohighlight hljs">   [Return:String] getCurveType(crv::Dict{String,Any})</code></pre><p>For any of the curves, their name can be changed by</p><pre><code class="nohighlight hljs">   setCurveName!(crv::Dict{String,Any}, name::String)</code></pre><p>and checked by</p><pre><code class="nohighlight hljs">   getCurveName(crv::Dict{String,Any})</code></pre><p>Otherwise there are special functions to change the parameters of curves</p><pre><code class="nohighlight hljs">   [Return:nothing] setXEqn!(crv::Dict{String,Any}, eqn::String)
   [Return:nothing] setYEqn!(crv::Dict{String,Any}, eqn::String)
   [Return:nothing] setZEqn!(crv::Dict{String,Any}, eqn::String)
   [Return:nothing] setStartPoint!(crv::Dict{String,Any}, point::Array{Float64})
   [Return:nothing] setEndPoint!(crv::Dict{String,Any}, point::Array{Float64})
   [Return:nothing] setArcUnits!(arc::Dict{String,Any}, units::String)
   [Return:nothing] setArcCenter!(arc::Dict{String,Any}, point::Array{Float64})
   [Return:nothing] setArcStartAngle!(arc::Dict{String,Any}, angle::Float64)
   [Return:nothing] setArcEndAngle!(arc::Dict{String,Any}, angle::Float64)
   [Return:nothing] setArcRadius!(arc::Dict{String,Any}, radius::Float64)

   [Return:String]         getXEqn(crv::Dict{String,Any})
   [Return:String]         getYEqn(crv::Dict{String,Any})
   [Return:String]         getZEqn(crv::Dict{String,Any})
   [Return:Array{Float64}] getStartPoint(crv::Dict{String,Any})
   [Return:Array{Float64}] getEndPoint(crv::Dict{String,Any})
   [Return:String]         getArcUnits(arc::Dict{String,Any})
   [Return:Array{Float64}] getArcCenter(arc::Dict{String,Any})
   [Return:Float64]        getArcStartAngle(arc::Dict{String,Any})
   [Return:Float64]        getArcEndAngle(arc::Dict{String,Any})
   [Return:Float64]        getArcRadius(arc::Dict{String,Any})</code></pre><h2 id="Undo/redo"><a class="docs-heading-anchor" href="#Undo/redo">Undo/redo</a><a id="Undo/redo-1"></a><a class="docs-heading-anchor-permalink" href="#Undo/redo" title="Permalink"></a></h2><p>The interactive mesh functionality has unlimited undo/redo for most actions.</p><p>In interactive mode, actions can be undone by the commands</p><pre><code class="nohighlight hljs">   [Return:String] undo()
   [Return:String] redo()</code></pre><p>where the return string contains the name of the action performed.</p><p>To find out what the next actions are, use</p><pre><code class="nohighlight hljs">   [Return:String] undoActionName()
   [Return:String] redoActionName()</code></pre><p>Finally, to clear the undo stack, use</p><pre><code class="nohighlight hljs">   [Return:nothing] clearUndoRedo()</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guided-tour/">« Guided tour</a><a class="docs-footer-nextpage" href="../CheatSheet/">Commands Cheat Sheet »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 13 October 2023 09:29">Friday 13 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
